From dfdb147844ea6c6448a38ab7a69c514c34879fda Mon Sep 17 00:00:00 2001
From: Michael Forney <mforney@mforney.org>
Date: Sat, 26 Oct 2019 02:05:31 -0700
Subject: [PATCH] Track generated xkbcomp parser

Generated with

	yacc -H parser.h -o parser.c p _xkbcommon_ parser.y
---
 src/xkbcomp/parser.c | 3382 ++++++++++++++++++++++++++++++++++++++++++
 src/xkbcomp/parser.h |  104 ++
 2 files changed, 3486 insertions(+)
 create mode 100644 src/xkbcomp/parser.c
 create mode 100644 src/xkbcomp/parser.h

diff --git a/src/xkbcomp/parser.c b/src/xkbcomp/parser.c
new file mode 100644
index 0000000..34e9ca8
--- /dev/null
+++ b/src/xkbcomp/parser.c
@@ -0,0 +1,3382 @@
+/* original parser id follows */
+/* yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93" */
+/* (use YYMAJOR/YYMINOR for ifdefs dependent on parser version) */
+
+#define YYBYACC 1
+#define YYMAJOR 2
+#define YYMINOR 0
+#define YYPATCH 20240109
+
+#define YYEMPTY        (-1)
+#define yyclearin      (yychar = YYEMPTY)
+#define yyerrok        (yyerrflag = 0)
+#define YYRECOVERING() (yyerrflag != 0)
+#define YYENOMEM       (-2)
+#define YYEOF          0
+#undef YYBTYACC
+#define YYBTYACC 0
+#define YYDEBUGSTR YYPREFIX "debug"
+
+#ifndef yyparse
+#define yyparse    _xkbcommon_parse
+#endif /* yyparse */
+
+#ifndef yylex
+#define yylex      _xkbcommon_lex
+#endif /* yylex */
+
+#ifndef yyerror
+#define yyerror    _xkbcommon_error
+#endif /* yyerror */
+
+#ifndef yychar
+#define yychar     _xkbcommon_char
+#endif /* yychar */
+
+#ifndef yyval
+#define yyval      _xkbcommon_val
+#endif /* yyval */
+
+#ifndef yylval
+#define yylval     _xkbcommon_lval
+#endif /* yylval */
+
+#ifndef yydebug
+#define yydebug    _xkbcommon_debug
+#endif /* yydebug */
+
+#ifndef yynerrs
+#define yynerrs    _xkbcommon_nerrs
+#endif /* yynerrs */
+
+#ifndef yyerrflag
+#define yyerrflag  _xkbcommon_errflag
+#endif /* yyerrflag */
+
+#ifndef yylhs
+#define yylhs      _xkbcommon_lhs
+#endif /* yylhs */
+
+#ifndef yylen
+#define yylen      _xkbcommon_len
+#endif /* yylen */
+
+#ifndef yydefred
+#define yydefred   _xkbcommon_defred
+#endif /* yydefred */
+
+#ifndef yystos
+#define yystos     _xkbcommon_stos
+#endif /* yystos */
+
+#ifndef yydgoto
+#define yydgoto    _xkbcommon_dgoto
+#endif /* yydgoto */
+
+#ifndef yysindex
+#define yysindex   _xkbcommon_sindex
+#endif /* yysindex */
+
+#ifndef yyrindex
+#define yyrindex   _xkbcommon_rindex
+#endif /* yyrindex */
+
+#ifndef yygindex
+#define yygindex   _xkbcommon_gindex
+#endif /* yygindex */
+
+#ifndef yytable
+#define yytable    _xkbcommon_table
+#endif /* yytable */
+
+#ifndef yycheck
+#define yycheck    _xkbcommon_check
+#endif /* yycheck */
+
+#ifndef yyname
+#define yyname     _xkbcommon_name
+#endif /* yyname */
+
+#ifndef yyrule
+#define yyrule     _xkbcommon_rule
+#endif /* yyrule */
+
+#if YYBTYACC
+
+#ifndef yycindex
+#define yycindex   _xkbcommon_cindex
+#endif /* yycindex */
+
+#ifndef yyctable
+#define yyctable   _xkbcommon_ctable
+#endif /* yyctable */
+
+#endif /* YYBTYACC */
+
+#define YYPREFIX "_xkbcommon_"
+
+#define YYPURE 1
+
+#line 34 "parser.y"
+#include "config.h"
+
+#include "xkbcomp/xkbcomp-priv.h"
+#include "xkbcomp/ast-build.h"
+#include "xkbcomp/parser-priv.h"
+#include "scanner-utils.h"
+#include "keysym.h"
+
+struct parser_param {
+    struct xkb_context *ctx;
+    struct scanner *scanner;
+    XkbFile *rtrn;
+    bool more_maps;
+};
+
+#define parser_err(param, error_id, fmt, ...) \
+    scanner_err_with_code((param)->scanner, error_id, fmt, ##__VA_ARGS__)
+
+#define parser_warn(param, warning_id, fmt, ...) \
+    scanner_warn_with_code((param)->scanner, warning_id, fmt, ##__VA_ARGS__)
+
+static void
+_xkbcommon_error(struct parser_param *param, const char *msg)
+{
+    parser_err(param, XKB_ERROR_INVALID_SYNTAX, "%s", msg);
+}
+
+static bool
+resolve_keysym(const char *name, xkb_keysym_t *sym_rtrn)
+{
+    xkb_keysym_t sym;
+
+    if (!name || istreq(name, "any") || istreq(name, "nosymbol")) {
+        *sym_rtrn = XKB_KEY_NoSymbol;
+        return true;
+    }
+
+    if (istreq(name, "none") || istreq(name, "voidsymbol")) {
+        *sym_rtrn = XKB_KEY_VoidSymbol;
+        return true;
+    }
+
+    sym = xkb_keysym_from_name(name, XKB_KEYSYM_NO_FLAGS);
+    if (sym != XKB_KEY_NoSymbol) {
+        *sym_rtrn = sym;
+        return true;
+    }
+
+    return false;
+}
+
+#define param_scanner param->scanner
+#ifdef YYSTYPE
+#undef  YYSTYPE_IS_DECLARED
+#define YYSTYPE_IS_DECLARED 1
+#endif
+#ifndef YYSTYPE_IS_DECLARED
+#define YYSTYPE_IS_DECLARED 1
+#line 165 "parser.y"
+typedef union YYSTYPE  {
+        int64_t          num;
+        enum xkb_file_type file_type;
+        char            *str;
+        xkb_atom_t      atom;
+        enum merge_mode merge;
+        enum xkb_map_flags mapFlags;
+        xkb_keysym_t    keysym;
+        ParseCommon     *any;
+        struct { ParseCommon *head; ParseCommon *last; } anyList;
+        ExprDef         *expr;
+        struct { ExprDef *head; ExprDef *last; } exprList;
+        VarDef          *var;
+        struct { VarDef *head; VarDef *last; } varList;
+        VModDef         *vmod;
+        struct { VModDef *head; VModDef *last; } vmodList;
+        InterpDef       *interp;
+        KeyTypeDef      *keyType;
+        SymbolsDef      *syms;
+        ModMapDef       *modMask;
+        GroupCompatDef  *groupCompat;
+        LedMapDef       *ledMap;
+        LedNameDef      *ledName;
+        KeycodeDef      *keyCode;
+        KeyAliasDef     *keyAlias;
+        void            *geom;
+        XkbFile         *file;
+        struct { XkbFile *head; XkbFile *last; } fileList;
+} YYSTYPE;
+#endif /* !YYSTYPE_IS_DECLARED */
+#line 211 "parser.c"
+
+/* compatibility with bison */
+#ifdef YYPARSE_PARAM
+/* compatibility with FreeBSD */
+# ifdef YYPARSE_PARAM_TYPE
+#  define YYPARSE_DECL() yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)
+# else
+#  define YYPARSE_DECL() yyparse(void *YYPARSE_PARAM)
+# endif
+#else
+# define YYPARSE_DECL() yyparse(struct parser_param *param)
+#endif
+
+/* Parameters sent to lex. */
+#ifdef YYLEX_PARAM
+# ifdef YYLEX_PARAM_TYPE
+#  define YYLEX_DECL() yylex(YYSTYPE *yylval, YYLEX_PARAM_TYPE YYLEX_PARAM)
+# else
+#  define YYLEX_DECL() yylex(YYSTYPE *yylval, void * YYLEX_PARAM)
+# endif
+# define YYLEX yylex(&yylval, YYLEX_PARAM)
+#else
+# define YYLEX_DECL() yylex(YYSTYPE *yylval, struct scanner *param_scanner)
+# define YYLEX yylex(&yylval, param_scanner)
+#endif
+
+/* Parameters sent to yyerror. */
+#ifndef YYERROR_DECL
+#define YYERROR_DECL() yyerror(struct parser_param *param, const char *s)
+#endif
+#ifndef YYERROR_CALL
+#define YYERROR_CALL(msg) yyerror(param, msg)
+#endif
+
+#ifndef YYDESTRUCT_DECL
+#define YYDESTRUCT_DECL() yydestruct(const char *msg, int psymb, YYSTYPE *val, struct parser_param *param)
+#endif
+#ifndef YYDESTRUCT_CALL
+#define YYDESTRUCT_CALL(msg, psymb, val) yydestruct(msg, psymb, val, param)
+#endif
+
+extern int YYPARSE_DECL();
+
+#define END_OF_FILE 0
+#define ERROR_TOK 255
+#define XKB_KEYMAP 1
+#define XKB_KEYCODES 2
+#define XKB_TYPES 3
+#define XKB_SYMBOLS 4
+#define XKB_COMPATMAP 5
+#define XKB_GEOMETRY 6
+#define XKB_SEMANTICS 7
+#define XKB_LAYOUT 8
+#define INCLUDE 10
+#define OVERRIDE 11
+#define AUGMENT 12
+#define REPLACE 13
+#define ALTERNATE 14
+#define VIRTUAL_MODS 20
+#define TYPE 21
+#define INTERPRET 22
+#define ACTION_TOK 23
+#define KEY 24
+#define ALIAS 25
+#define GROUP 26
+#define MODIFIER_MAP 27
+#define INDICATOR 28
+#define SHAPE 29
+#define KEYS 30
+#define ROW 31
+#define SECTION 32
+#define OVERLAY 33
+#define TEXT 34
+#define OUTLINE 35
+#define SOLID 36
+#define LOGO 37
+#define VIRTUAL 38
+#define EQUALS 40
+#define PLUS 41
+#define MINUS 42
+#define DIVIDE 43
+#define TIMES 44
+#define OBRACE 45
+#define CBRACE 46
+#define OPAREN 47
+#define CPAREN 48
+#define OBRACKET 49
+#define CBRACKET 50
+#define DOT 51
+#define COMMA 52
+#define SEMI 53
+#define EXCLAM 54
+#define INVERT 55
+#define STRING 60
+#define INTEGER 61
+#define FLOAT 62
+#define IDENT 63
+#define KEYNAME 64
+#define PARTIAL 70
+#define DEFAULT 71
+#define HIDDEN 72
+#define ALPHANUMERIC_KEYS 73
+#define MODIFIER_KEYS 74
+#define KEYPAD_KEYS 75
+#define FUNCTION_KEYS 76
+#define ALTERNATE_GROUP 77
+#define YYERRCODE 256
+typedef int YYINT;
+static const YYINT _xkbcommon_lhs[] = {                  -1,
+    0,    0,    0,   70,    9,    9,    9,   69,   69,   68,
+   10,   10,   10,   10,   10,   13,   13,   12,   12,   11,
+   11,   11,   11,   11,   11,   11,   11,   22,   22,   22,
+   21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
+   21,   21,   21,   21,   37,   37,   37,   52,   53,   43,
+   42,   42,   41,   41,   44,   45,   45,   39,   39,   46,
+   47,   40,   40,   38,   38,   38,   38,   38,   27,   27,
+   49,   48,   50,   51,   51,   54,   54,   55,   56,   56,
+   57,   57,   57,   57,   57,   58,   58,   59,   59,   60,
+   60,   61,   61,   62,   63,   63,   64,   65,   65,   66,
+   66,   66,   33,   33,   32,   67,    6,    6,    6,    6,
+   16,   16,   18,   18,   18,   18,   18,   18,   18,   18,
+   18,   18,   18,    8,    8,    7,    7,    7,    7,    7,
+   34,   34,   35,   35,   23,   23,   23,   23,   23,   23,
+   24,   24,   24,   24,   24,   24,   24,   24,   36,   36,
+   31,   25,   25,   25,   25,   26,   26,   26,   26,   29,
+   29,   30,   30,   30,   30,   28,   20,   20,   20,    5,
+    5,    2,    2,    4,    3,    1,   17,   17,   19,   15,
+   15,   14,
+};
+static const YYINT _xkbcommon_len[] = {                   2,
+    1,    1,    1,    7,    1,    1,    1,    2,    1,    7,
+    1,    1,    1,    1,    1,    1,    0,    2,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    2,    3,    0,
+    2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
+    2,    2,    2,    2,    4,    2,    3,    4,    5,    3,
+    3,    1,    1,    3,    6,    3,    1,    2,    1,    6,
+    6,    3,    1,    3,    3,    1,    2,    1,    3,    3,
+    5,    6,    6,    5,    6,    6,    6,    6,    2,    1,
+    5,    1,    1,    1,    1,    2,    1,    5,    1,    3,
+    1,    1,    3,    6,    3,    1,    3,    3,    1,    3,
+    5,    3,    3,    1,    5,    6,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    0,    1,    1,    1,    1,    1,
+    1,    0,    3,    1,    3,    3,    3,    3,    3,    1,
+    2,    2,    2,    2,    1,    4,    1,    3,    3,    1,
+    4,    1,    3,    4,    6,    1,    1,    1,    1,    1,
+    0,    3,    3,    1,    1,    3,    1,    1,    1,    2,
+    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+    0,    1,
+};
+static const YYINT _xkbcommon_defred[] = {                0,
+    3,   20,   21,   22,   23,   24,   25,   26,   27,    0,
+   19,    0,    0,    2,    1,   18,    5,   11,   12,   14,
+   13,   15,    6,    7,    0,    0,  182,  180,    0,    0,
+    0,   30,    0,    9,    0,    0,    0,    8,  126,  128,
+  127,  129,  130,    0,    0,    0,   28,    4,   10,   44,
+    0,    0,    0,  113,    0,    0,    0,    0,    0,    0,
+  121,    0,    0,  108,  109,  110,    0,    0,  177,    0,
+  178,    0,    0,    0,  112,    0,   31,   29,   32,   35,
+   36,   37,   38,   39,   40,   33,   34,   41,   42,   43,
+    0,   52,    0,  179,    0,  168,  175,  167,  169,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   46,    0,    0,    0,   50,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   47,  176,    0,    0,  115,  114,  116,  117,
+  118,  119,  120,  122,  123,    0,    0,    0,    0,    0,
+  174,  159,  157,  158,    0,  111,  156,    0,  140,    0,
+  147,    0,    0,    0,   51,   59,    0,    0,    0,    0,
+    0,    0,    0,   68,   63,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  104,    0,    0,   99,    0,
+    0,    0,   82,   84,    0,   80,   85,   83,    0,   48,
+    0,  142,  145,  141,    0,  143,  144,    0,    0,    0,
+    0,    0,  154,    0,    0,   45,    0,   58,    0,    0,
+    0,    0,    0,  164,  165,    0,    0,  150,    0,   67,
+    0,    0,    0,   49,   71,    0,    0,   74,    0,    0,
+    0,  173,  172,  171,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   79,    0,    0,  148,    0,    0,    0,
+    0,  135,  138,    0,    0,   60,   55,    0,    0,   69,
+    0,   70,    0,    0,   65,   61,   62,   72,    0,   73,
+  100,  170,    0,    0,    0,   77,  103,   76,   98,    0,
+   89,    0,   87,    0,   78,   75,  106,  146,  155,  166,
+    0,  162,  163,  149,    0,    0,    0,    0,   86,    0,
+    0,   96,  151,  105,  101,    0,   92,    0,   91,   81,
+    0,    0,    0,    0,    0,    0,   97,   94,   95,   93,
+   88,   90,
+};
+#if defined(YYDESTRUCT_CALL) || defined(YYSTYPE_TOSTRING)
+static const YYINT _xkbcommon_stos[] = {                  0,
+    0,   70,   71,   72,   73,   74,   75,   76,   77,  258,
+  269,  270,  271,  326,  328,  269,    1,    2,    3,    4,
+    5,    6,    7,    8,  267,  268,   60,  272,  273,  273,
+   45,   45,  271,  326,  327,  280,   46,  326,   10,   11,
+   12,   13,   14,   46,  265,  266,  279,   53,   53,   60,
+   20,   21,   22,   23,   24,   25,   26,   27,   28,   29,
+   31,   32,   34,   35,   36,   37,   38,   54,   63,   64,
+   71,  264,  274,  275,  276,  283,  295,  301,  302,  304,
+  305,  306,  307,  308,  309,  310,  311,  312,  313,  325,
+  275,  299,  300,   60,  277,   32,   61,   63,  261,  278,
+  303,   64,   64,  261,  275,  261,  277,  277,  277,   28,
+  275,   40,  277,   49,   51,   53,   40,   40,   52,   53,
+   45,   41,   45,   45,   40,   40,   45,   40,   45,   45,
+   45,  261,   53,   61,  259,   45,   21,   22,   24,   26,
+   27,   28,   29,   32,   34,   41,   42,   47,   54,   55,
+   62,   64,  261,  262,  274,  275,  277,  281,  282,  283,
+  284,  274,  281,  281,  299,  295,  297,  281,  297,   49,
+   54,  275,  283,  285,  296,  298,   64,  281,  281,  293,
+  281,  297,   45,   49,  275,  290,  291,  323,  324,   28,
+   31,   33,  295,  308,  314,  315,  320,  325,   40,   53,
+  297,  282,  283,  282,  281,  282,  282,   47,   41,   42,
+   43,   44,   50,   40,   49,   53,   46,  295,   46,   32,
+   45,   63,  274,  278,  286,  287,  288,  289,  294,  275,
+   40,   46,   52,   53,   53,   46,   52,   53,   46,  291,
+   42,   61,   62,  260,  263,   40,   46,   52,   46,   52,
+   45,  277,   46,  315,  281,   46,   48,  292,  293,  281,
+  281,  281,  281,  281,  281,   53,   53,  288,   47,   50,
+   52,   50,   52,  281,  285,   53,  296,   53,  281,   53,
+   46,  260,   52,   45,  281,   53,  290,   53,  324,   30,
+  295,  316,  317,   45,   53,   53,   53,   48,   50,   46,
+  292,  278,  286,  289,  263,  291,   45,   46,  317,   64,
+  321,  322,   48,   50,   46,   45,   64,  318,  319,   53,
+   40,   46,   52,  293,   46,   52,   64,   53,  322,   46,
+   53,  319,
+};
+#endif /* YYDESTRUCT_CALL || YYSTYPE_TOSTRING */
+static const YYINT _xkbcommon_dgoto[] = {                10,
+  135,  244,  153,  154,  245,   72,   45,   46,   25,   26,
+   11,   12,   33,   28,   29,  155,  156,   75,  157,  224,
+   47,   36,  179,  159,  160,  161,  174,  225,  226,  227,
+  228,  186,  187,  258,  259,  229,  166,  175,  167,  176,
+   92,   93,   78,   79,  101,   80,   81,   82,   83,  194,
+   85,   86,   87,   88,   89,  195,  196,  292,  293,  318,
+  319,  197,  311,  312,  188,  189,  198,   14,   35,   15,
+};
+static const YYINT _xkbcommon_sindex[] = {              164,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  499,  823,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   -2,   -2,    0,    0,  -13,   26,
+  499,    0,  623,    0,  154,   15,  -44,    0,    0,    0,
+    0,    0,    0,   23,   32,   16,    0,    0,    0,    0,
+  -56,   40,    2,    0,   98,  108,  121,  -56,    6,   40,
+    0,   40,    0,    0,    0,    0,  189,  -56,    0,  192,
+    0,   40,   79,  202,    0,  227,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  253,    0,  141,    0,  269,    0,    0,    0,    0,  257,
+  282,  283,  290,  302,  300,  315,  333,  337,  351,  121,
+  320,  348,  366,  422,  776,    0,  422,  422,  -56,    0,
+  752,  422,  752,  570,  368,  422,  422,  422,  752,  -14,
+  514,  385,    0,    0,  380,  752,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,  422,  422,  422,  422,  422,
+    0,    0,    0,    0,   97,    0,    0,   66,    0,  401,
+    0,  393,  115,  201,    0,    0,  584,  201,  622,  638,
+  -56,    0,  412,    0,    0,  -36,  402,  133,  201,  -22,
+  260,  684,  408,   56,  418,    0,   74,   81,    0,   40,
+  414,   40,    0,    0,  468,    0,    0,    0,  422,    0,
+  700,    0,    0,    0,  326,    0,    0,  422,  422,  422,
+  422,  422,    0,  422,  422,    0,  407,    0,  421,    0,
+   36,    0,  424,    0,    0,  417,  423,    0,  255,    0,
+  330,  425,  570,    0,    0,  426,  422,    0,  427,  119,
+  160,    0,    0,    0,  429,  376,  434,  408,  435,    1,
+  738,  453,  463,    0,  268,  465,    0,  458,  472,  276,
+  276,    0,    0,  201,  345,    0,    0,  143,  422,    0,
+   36,    0,  776,  201,    0,    0,    0,    0,  201,    0,
+    0,    0,   56,  408,  201,    0,    0,    0,    0,  484,
+    0,  532,    0,  470,    0,    0,    0,    0,    0,    0,
+  496,    0,    0,    0,  502,  217,   10,  504,    0,  525,
+  220,    0,    0,    0,    0,  422,    0,  277,    0,    0,
+  503,  526,  470,  360,  527,   10,    0,    0,    0,    0,
+    0,    0,
+};
+static const YYINT _xkbcommon_rindex[] = {              847,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  855,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  537,  537,    0,    0,    0,    0,
+  692,    0,    0,    0,  692,  254,    0,    0,    0,    0,
+    0,    0,    0,    0,  312,    0,    0,    0,    0,    0,
+    0,   55,   73,    0,   91,    0,  112,  129,  157,  161,
+    0,  219,   42,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,  544,  222,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  328,    0,    0,    0,    0,    0,    0,    0,    0,  543,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  208,    0,    0,    0,    0,  636,
+    0,  467,    0,  361,    0,    0,    0,  545,    0,  539,
+    0,  139,    0,    0,    0,    0,    0,    0,  475,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  157,
+  275,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  552,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,  -33,
+    0,  313,    0,    0,    0,    0,  559,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  566,  374,
+  420,    0,    0,  480,    0,    0,    0,    0,  552,    0,
+    0,    0,    0,  382,    0,    0,    0,    0,  535,    0,
+    0,    0,    0,    0,  383,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,
+};
+#if YYBTYACC
+static const YYINT _xkbcommon_cindex[] = {                0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,
+};
+#endif
+static const YYINT _xkbcommon_gindex[] = {                0,
+    0,  379,  -51,    0,  334,    0,    0,    0,    0,    0,
+  609,    0,  637,    0,  596,   14,  -46,    0,  -39,  -52,
+    0,    0,   85,  485,  -35,    0,  392,  365,    0,  419,
+  369,  391, -179,  388, -124,    0,  -28,  430,  -67,    0,
+  533,    0,    0,    0,    0,    0,    0,    0,    0,  612,
+    0,    0,    0,    0,    0,    0,  476,    0,  381,    0,
+  349,    0,    0,  364,    0,  440,  628,  183,    0,    0,
+};
+#define YYTABLESIZE 863
+static const YYINT _xkbcommon_table[] = {                74,
+  100,   99,  180,  240,   91,  104,   69,  106,   48,  232,
+   76,  105,   95,  122,   71,  233,  168,   77,  168,  107,
+  108,  111,  109,  236,   39,   40,   41,   42,   43,  237,
+  183,   31,  113,   96,  184,   51,   52,   53,   54,   55,
+   56,   57,   58,   59,   60,  183,   61,   62,   69,   63,
+   64,   65,   66,   67,  316,  169,   71,   27,  132,   73,
+   44,  182,   97,   69,   98,   94,   97,   96,  201,   68,
+   32,   71,   91,  317,   74,   49,   74,  172,   69,   70,
+  221,  123,   74,  185,   74,   76,   71,   76,  173,   74,
+  123,   50,  123,   76,  115,   76,   97,  241,   98,   94,
+   76,  107,  193,  115,  306,  115,  209,  210,  211,  212,
+  203,  203,  114,  203,  203,  213,  242,  243,   99,  247,
+   74,  114,   74,  114,  230,  248,  249,  114,  162,  115,
+  116,   76,  250,   76,   73,   74,   73,   73,  218,  116,
+  218,  116,   73,  208,   73,  114,   76,  115,   74,   73,
+  107,  117,  252,  218,   74,  209,  210,  211,  212,   76,
+  117,  102,  117,    1,  281,   76,  193,  216,  118,   99,
+  248,  103,  218,  209,  210,  211,  212,  118,  111,  118,
+   73,   97,   73,  223,   66,  235,  172,  111,  300,  111,
+   66,  324,  119,  120,  271,   73,  119,  173,  158,   37,
+  120,  163,  164,  185,   74,  119,  168,  119,   73,  120,
+  178,  120,  181,   34,   73,   76,  110,   38,  302,   99,
+  242,  243,  291,    2,    3,    4,    5,    6,    7,    8,
+    9,  112,  205,    2,    3,    4,    5,    6,    7,    8,
+    9,  209,  210,  211,  212,   74,   73,  152,  152,  152,
+  152,  152,  152,  152,  116,  152,   76,  152,  122,  152,
+  152,  111,  315,  291,   73,  322,  117,  122,  248,  122,
+  111,  323,  111,  125,  125,  125,  125,  125,  125,  125,
+  125,  125,  125,  255,  125,  125,  223,  125,  125,  125,
+  125,  125,  118,  260,  261,  262,  263,  122,  264,  265,
+  209,  210,  211,  212,  272,   73,  273,  125,  209,  210,
+  211,  212,  238,  121,  121,  274,  125,  125,  211,  212,
+  296,  279,  325,  121,  125,  121,  123,  124,  326,  125,
+  285,  124,  124,  124,  124,  124,  124,  124,  124,  124,
+  124,  126,  124,  124,  127,  124,  124,  124,  124,  124,
+  137,  138,   54,  139,  128,  140,  141,  142,  143,  177,
+   61,  144,  167,  145,  167,  124,  209,  210,  211,  212,
+  146,  147,  133,  257,  124,  124,  148,  129,  170,   53,
+   53,  130,  124,  149,  150,  209,  210,  211,  212,   94,
+   97,  151,   69,  152,  299,  131,  137,  138,   54,  139,
+   71,  140,  141,  142,  143,  330,   61,  144,  134,  145,
+  136,  237,   54,   54,  136,  136,  146,  147,  136,  136,
+  284,  136,  148,  136,  199,  136,  136,   64,  102,  149,
+  150,  177,  200,   64,  102,   94,   97,  151,   69,  152,
+  214,  215,  137,  138,   54,  139,   71,  140,  141,  142,
+  143,  231,   61,  144,  234,  145,  184,  246,  251,  266,
+  137,  137,  146,  147,  137,  137,  270,  137,  148,  137,
+  269,  137,  137,  267,  271,  149,  150,  276,  278,  280,
+  283,   94,   97,  151,   69,  152,  286,  288,  137,  138,
+   54,  139,   71,  140,  141,  190,  143,  294,  191,  144,
+  192,   63,   64,   65,   66,  298,  153,  153,  153,  153,
+  153,  153,  153,  253,  153,  295,  153,  297,  153,  153,
+  134,   68,  134,  237,  139,  139,  134,  139,  307,  139,
+   69,  139,  139,  310,  137,  138,   54,  139,   71,  140,
+  141,  190,  143,  313,  191,  144,  192,   63,   64,   65,
+   66,  314,  137,  138,   54,  139,  320,  140,  141,  142,
+  143,  290,   61,  144,  321,  145,  327,   68,    2,    3,
+    4,    5,    6,    7,    8,    9,   69,  308,  328,  331,
+  133,  181,  133,  152,   71,   68,  133,   57,  161,   56,
+  137,  138,   54,  139,   69,  140,  141,  142,  143,  132,
+   61,  144,   71,  145,  137,  138,   54,  139,  160,  140,
+  141,  142,  143,  131,   61,  144,  305,  145,  170,  282,
+   16,   30,  275,  171,   18,   19,   20,   21,   22,  217,
+  202,  204,   69,  206,  207,  303,   13,   68,  287,  268,
+   71,  304,  137,  138,   54,  139,   69,  140,  141,  142,
+  143,  165,   61,  144,   71,  145,  301,   84,  137,  138,
+   54,  139,  277,  140,  141,  142,  143,  219,   61,  220,
+  254,  145,  309,   90,  332,   68,  145,  145,  145,  145,
+  145,  145,  221,  145,   69,  145,  329,  145,  145,  289,
+    0,    0,   71,   17,   17,   17,   17,   17,   97,    0,
+  222,    0,    0,    0,  137,  138,   54,  139,   71,  140,
+  141,  142,  143,    0,   61,  144,    0,  145,    0,    0,
+  137,  138,   54,  139,    0,  140,  141,  142,  143,  239,
+   61,  144,    0,  145,    0,    0,    0,   68,    0,    0,
+    0,    0,    0,    0,    0,  256,   69,    0,    0,    0,
+    0,    0,    0,   68,   71,    0,    0,    0,  137,  138,
+   54,  139,   69,  140,  141,  142,  143,  290,   61,  144,
+   71,  145,  137,  138,   54,  139,    0,  140,  141,  142,
+  143,    0,   61,  144,    0,  145,    0,    0,    0,    0,
+    0,   68,    0,    0,    0,    0,  137,  138,   54,  139,
+   69,  140,  141,  142,  143,   68,   61,  144,   71,  145,
+    0,    0,    0,    0,   69,    0,    0,    0,    0,    0,
+    0,    0,   71,   17,   18,   19,   20,   21,   22,   23,
+   24,    0,    0,    0,    0,    0,    0,    0,   69,    0,
+    0,    0,    0,    0,    0,    0,   71,   17,   17,   17,
+   17,   17,   17,   17,   17,   16,   16,   16,   16,   16,
+   16,   16,   16,
+};
+static const YYINT _xkbcommon_check[] = {                46,
+   53,   53,  127,  183,   51,   57,   63,   59,   53,   46,
+   46,   58,   52,   47,   71,   52,   50,   46,   52,   59,
+   60,   68,   62,   46,   10,   11,   12,   13,   14,   52,
+   45,   45,   72,   32,   49,   20,   21,   22,   23,   24,
+   25,   26,   27,   28,   29,   45,   31,   32,   63,   34,
+   35,   36,   37,   38,   45,  123,   71,   60,  110,   46,
+   46,  129,   61,   63,   63,   60,   61,   32,  136,   54,
+   45,   71,  119,   64,  121,   53,  123,  124,   63,   64,
+   45,   40,  129,  130,  131,  121,   71,  123,  124,  136,
+   49,   60,   51,  129,   40,  131,   61,   42,   63,   60,
+  136,   60,  131,   49,  284,   51,   41,   42,   43,   44,
+  146,  147,   40,  149,  150,   50,   61,   62,  170,   46,
+  167,   49,  169,   51,  171,   52,   46,   49,  115,   51,
+   40,  167,   52,  169,  121,  182,  123,  124,  167,   49,
+  169,   51,  129,   47,  131,   49,  182,   51,  195,  136,
+  190,   40,  192,  182,  201,   41,   42,   43,   44,  195,
+   49,   64,   51,    0,   46,  201,  195,   53,   40,  221,
+   52,   64,  201,   41,   42,   43,   44,   49,   40,   51,
+  167,   61,  169,  170,   46,   53,  233,   49,   46,   51,
+   52,  316,   52,   53,   52,  182,   40,  233,  114,   46,
+   40,  117,  118,  250,  251,   49,  122,   51,  195,   49,
+  126,   51,  128,   31,  201,  251,   28,   35,  271,  271,
+   61,   62,  251,   70,   71,   72,   73,   74,   75,   76,
+   77,   40,  148,   70,   71,   72,   73,   74,   75,   76,
+   77,   41,   42,   43,   44,  292,  233,   40,   41,   42,
+   43,   44,   45,   46,   53,   48,  292,   50,   40,   52,
+   53,   40,   46,  292,  251,   46,   40,   49,   52,   51,
+   49,   52,   51,   20,   21,   22,   23,   24,   25,   26,
+   27,   28,   29,  199,   31,   32,  273,   34,   35,   36,
+   37,   38,   40,  209,  210,  211,  212,   41,  214,  215,
+   41,   42,   43,   44,   50,  292,   52,   54,   41,   42,
+   43,   44,   53,   45,   40,  231,   63,   64,   43,   44,
+   53,  237,   46,   49,   71,   51,   45,   45,   52,   40,
+  246,   20,   21,   22,   23,   24,   25,   26,   27,   28,
+   29,   40,   31,   32,   45,   34,   35,   36,   37,   38,
+   21,   22,   23,   24,   40,   26,   27,   28,   29,   47,
+   31,   32,   50,   34,   52,   54,   41,   42,   43,   44,
+   41,   42,   53,   48,   63,   64,   47,   45,   49,   52,
+   53,   45,   71,   54,   55,   41,   42,   43,   44,   60,
+   61,   62,   63,   64,   50,   45,   21,   22,   23,   24,
+   71,   26,   27,   28,   29,   46,   31,   32,   61,   34,
+   45,   52,   52,   53,   41,   42,   41,   42,   45,   46,
+   45,   48,   47,   50,   40,   52,   53,   46,   46,   54,
+   55,   64,   53,   52,   52,   60,   61,   62,   63,   64,
+   40,   49,   21,   22,   23,   24,   71,   26,   27,   28,
+   29,   40,   31,   32,   53,   34,   49,   40,   45,   53,
+   41,   42,   41,   42,   45,   46,   50,   48,   47,   50,
+   47,   52,   53,   53,   52,   54,   55,   53,   53,   53,
+   52,   60,   61,   62,   63,   64,   53,   53,   21,   22,
+   23,   24,   71,   26,   27,   28,   29,   45,   31,   32,
+   33,   34,   35,   36,   37,   48,   40,   41,   42,   43,
+   44,   45,   46,   46,   48,   53,   50,   53,   52,   53,
+   46,   54,   48,   52,   45,   46,   52,   48,   45,   50,
+   63,   52,   53,   64,   21,   22,   23,   24,   71,   26,
+   27,   28,   29,   48,   31,   32,   33,   34,   35,   36,
+   37,   50,   21,   22,   23,   24,   53,   26,   27,   28,
+   29,   30,   31,   32,   40,   34,   64,   54,   70,   71,
+   72,   73,   74,   75,   76,   77,   63,   46,   53,   53,
+   46,   45,   48,   40,   71,   54,   52,   45,   50,   45,
+   21,   22,   23,   24,   63,   26,   27,   28,   29,   48,
+   31,   32,   71,   34,   21,   22,   23,   24,   50,   26,
+   27,   28,   29,   48,   31,   32,  283,   34,   49,  241,
+   12,   26,  231,   54,    2,    3,    4,    5,    6,   46,
+  146,  147,   63,  149,  150,  271,    0,   54,  248,  221,
+   71,  273,   21,   22,   23,   24,   63,   26,   27,   28,
+   29,  119,   31,   32,   71,   34,  269,   46,   21,   22,
+   23,   24,  233,   26,   27,   28,   29,   46,   31,   32,
+  195,   34,  292,   46,  326,   54,   41,   42,   43,   44,
+   45,   46,   45,   48,   63,   50,  323,   52,   53,  250,
+   -1,   -1,   71,    2,    3,    4,    5,    6,   61,   -1,
+   63,   -1,   -1,   -1,   21,   22,   23,   24,   71,   26,
+   27,   28,   29,   -1,   31,   32,   -1,   34,   -1,   -1,
+   21,   22,   23,   24,   -1,   26,   27,   28,   29,   46,
+   31,   32,   -1,   34,   -1,   -1,   -1,   54,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   46,   63,   -1,   -1,   -1,
+   -1,   -1,   -1,   54,   71,   -1,   -1,   -1,   21,   22,
+   23,   24,   63,   26,   27,   28,   29,   30,   31,   32,
+   71,   34,   21,   22,   23,   24,   -1,   26,   27,   28,
+   29,   -1,   31,   32,   -1,   34,   -1,   -1,   -1,   -1,
+   -1,   54,   -1,   -1,   -1,   -1,   21,   22,   23,   24,
+   63,   26,   27,   28,   29,   54,   31,   32,   71,   34,
+   -1,   -1,   -1,   -1,   63,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   71,    1,    2,    3,    4,    5,    6,    7,
+    8,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   63,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   71,    1,    2,    3,
+    4,    5,    6,    7,    8,    1,    2,    3,    4,    5,
+    6,    7,    8,
+};
+#if YYBTYACC
+static const YYINT _xkbcommon_ctable[] = {               -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,
+};
+#endif
+#define YYFINAL 10
+#ifndef YYDEBUG
+#define YYDEBUG 0
+#endif
+#define YYMAXTOKEN 256
+#define YYUNDFTOKEN 329
+#define YYTRANSLATE(a) ((a) > YYMAXTOKEN ? YYUNDFTOKEN : (a))
+#if YYDEBUG
+static const char *const _xkbcommon_name[] = {
+
+"$end","XKB_KEYMAP","XKB_KEYCODES","XKB_TYPES","XKB_SYMBOLS","XKB_COMPATMAP",
+"XKB_GEOMETRY","XKB_SEMANTICS","XKB_LAYOUT",0,"INCLUDE","OVERRIDE","AUGMENT",
+"REPLACE","ALTERNATE",0,0,0,0,0,"VIRTUAL_MODS","TYPE","INTERPRET","ACTION_TOK",
+"KEY","ALIAS","GROUP","MODIFIER_MAP","INDICATOR","SHAPE","KEYS","ROW","SECTION",
+"OVERLAY","TEXT","OUTLINE","SOLID","LOGO","VIRTUAL",0,"EQUALS","PLUS","MINUS",
+"DIVIDE","TIMES","OBRACE","CBRACE","OPAREN","CPAREN","OBRACKET","CBRACKET",
+"DOT","COMMA","SEMI","EXCLAM","INVERT",0,0,0,0,"STRING","INTEGER","FLOAT",
+"IDENT","KEYNAME",0,0,0,0,0,"PARTIAL","DEFAULT","HIDDEN","ALPHANUMERIC_KEYS",
+"MODIFIER_KEYS","KEYPAD_KEYS","FUNCTION_KEYS","ALTERNATE_GROUP",0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,"ERROR_TOK","error","$accept","XkbFile","KeyCode","Number",
+"Integer","Float","SignedNumber","DoodadType","MergeMode","OptMergeMode",
+"XkbCompositeType","FileType","Flag","Flags","OptFlags","MapName","OptMapName",
+"FieldSpec","Ident","Element","String","KeySym","Decl","DeclList","Expr","Term",
+"Lhs","Terminal","ArrayInit","KeySyms","OptKeySymList","KeySymList","Action",
+"Coord","CoordList","OptExprList","ExprList","ActionList","VarDecl",
+"SymbolsVarDecl","VarDeclList","SymbolsBody","VModDef","VModDefList","VModDecl",
+"InterpretDecl","InterpretMatch","KeyTypeDecl","SymbolsDecl","ModMapDecl",
+"GroupCompatDecl","LedMapDecl","LedNameDecl","KeyNameDecl","KeyAliasDecl",
+"ShapeDecl","SectionDecl","SectionBody","SectionBodyItem","RowBody",
+"RowBodyItem","Keys","Key","OverlayDecl","OverlayKeyList","OverlayKey",
+"OutlineList","OutlineInList","DoodadDecl","XkbMapConfig","XkbMapConfigList",
+"XkbCompositeMap","illegal-symbol",
+};
+static const char *const _xkbcommon_rule[] = {
+"$accept : XkbFile",
+"XkbFile : XkbCompositeMap",
+"XkbFile : XkbMapConfig",
+"XkbFile : END_OF_FILE",
+"XkbCompositeMap : OptFlags XkbCompositeType OptMapName OBRACE XkbMapConfigList CBRACE SEMI",
+"XkbCompositeType : XKB_KEYMAP",
+"XkbCompositeType : XKB_SEMANTICS",
+"XkbCompositeType : XKB_LAYOUT",
+"XkbMapConfigList : XkbMapConfigList XkbMapConfig",
+"XkbMapConfigList : XkbMapConfig",
+"XkbMapConfig : OptFlags FileType OptMapName OBRACE DeclList CBRACE SEMI",
+"FileType : XKB_KEYCODES",
+"FileType : XKB_TYPES",
+"FileType : XKB_COMPATMAP",
+"FileType : XKB_SYMBOLS",
+"FileType : XKB_GEOMETRY",
+"OptFlags : Flags",
+"OptFlags :",
+"Flags : Flags Flag",
+"Flags : Flag",
+"Flag : PARTIAL",
+"Flag : DEFAULT",
+"Flag : HIDDEN",
+"Flag : ALPHANUMERIC_KEYS",
+"Flag : MODIFIER_KEYS",
+"Flag : KEYPAD_KEYS",
+"Flag : FUNCTION_KEYS",
+"Flag : ALTERNATE_GROUP",
+"DeclList : DeclList Decl",
+"DeclList : DeclList OptMergeMode VModDecl",
+"DeclList :",
+"Decl : OptMergeMode VarDecl",
+"Decl : OptMergeMode InterpretDecl",
+"Decl : OptMergeMode KeyNameDecl",
+"Decl : OptMergeMode KeyAliasDecl",
+"Decl : OptMergeMode KeyTypeDecl",
+"Decl : OptMergeMode SymbolsDecl",
+"Decl : OptMergeMode ModMapDecl",
+"Decl : OptMergeMode GroupCompatDecl",
+"Decl : OptMergeMode LedMapDecl",
+"Decl : OptMergeMode LedNameDecl",
+"Decl : OptMergeMode ShapeDecl",
+"Decl : OptMergeMode SectionDecl",
+"Decl : OptMergeMode DoodadDecl",
+"Decl : MergeMode STRING",
+"VarDecl : Lhs EQUALS Expr SEMI",
+"VarDecl : Ident SEMI",
+"VarDecl : EXCLAM Ident SEMI",
+"KeyNameDecl : KEYNAME EQUALS KeyCode SEMI",
+"KeyAliasDecl : ALIAS KEYNAME EQUALS KEYNAME SEMI",
+"VModDecl : VIRTUAL_MODS VModDefList SEMI",
+"VModDefList : VModDefList COMMA VModDef",
+"VModDefList : VModDef",
+"VModDef : Ident",
+"VModDef : Ident EQUALS Expr",
+"InterpretDecl : INTERPRET InterpretMatch OBRACE VarDeclList CBRACE SEMI",
+"InterpretMatch : KeySym PLUS Expr",
+"InterpretMatch : KeySym",
+"VarDeclList : VarDeclList VarDecl",
+"VarDeclList : VarDecl",
+"KeyTypeDecl : TYPE String OBRACE VarDeclList CBRACE SEMI",
+"SymbolsDecl : KEY KEYNAME OBRACE SymbolsBody CBRACE SEMI",
+"SymbolsBody : SymbolsBody COMMA SymbolsVarDecl",
+"SymbolsBody : SymbolsVarDecl",
+"SymbolsVarDecl : Lhs EQUALS Expr",
+"SymbolsVarDecl : Lhs EQUALS ArrayInit",
+"SymbolsVarDecl : Ident",
+"SymbolsVarDecl : EXCLAM Ident",
+"SymbolsVarDecl : ArrayInit",
+"ArrayInit : OBRACKET OptKeySymList CBRACKET",
+"ArrayInit : OBRACKET ActionList CBRACKET",
+"GroupCompatDecl : GROUP Integer EQUALS Expr SEMI",
+"ModMapDecl : MODIFIER_MAP Ident OBRACE ExprList CBRACE SEMI",
+"LedMapDecl : INDICATOR String OBRACE VarDeclList CBRACE SEMI",
+"LedNameDecl : INDICATOR Integer EQUALS Expr SEMI",
+"LedNameDecl : VIRTUAL INDICATOR Integer EQUALS Expr SEMI",
+"ShapeDecl : SHAPE String OBRACE OutlineList CBRACE SEMI",
+"ShapeDecl : SHAPE String OBRACE CoordList CBRACE SEMI",
+"SectionDecl : SECTION String OBRACE SectionBody CBRACE SEMI",
+"SectionBody : SectionBody SectionBodyItem",
+"SectionBody : SectionBodyItem",
+"SectionBodyItem : ROW OBRACE RowBody CBRACE SEMI",
+"SectionBodyItem : VarDecl",
+"SectionBodyItem : DoodadDecl",
+"SectionBodyItem : LedMapDecl",
+"SectionBodyItem : OverlayDecl",
+"RowBody : RowBody RowBodyItem",
+"RowBody : RowBodyItem",
+"RowBodyItem : KEYS OBRACE Keys CBRACE SEMI",
+"RowBodyItem : VarDecl",
+"Keys : Keys COMMA Key",
+"Keys : Key",
+"Key : KEYNAME",
+"Key : OBRACE ExprList CBRACE",
+"OverlayDecl : OVERLAY String OBRACE OverlayKeyList CBRACE SEMI",
+"OverlayKeyList : OverlayKeyList COMMA OverlayKey",
+"OverlayKeyList : OverlayKey",
+"OverlayKey : KEYNAME EQUALS KEYNAME",
+"OutlineList : OutlineList COMMA OutlineInList",
+"OutlineList : OutlineInList",
+"OutlineInList : OBRACE CoordList CBRACE",
+"OutlineInList : Ident EQUALS OBRACE CoordList CBRACE",
+"OutlineInList : Ident EQUALS Expr",
+"CoordList : CoordList COMMA Coord",
+"CoordList : Coord",
+"Coord : OBRACKET SignedNumber COMMA SignedNumber CBRACKET",
+"DoodadDecl : DoodadType String OBRACE VarDeclList CBRACE SEMI",
+"DoodadType : TEXT",
+"DoodadType : OUTLINE",
+"DoodadType : SOLID",
+"DoodadType : LOGO",
+"FieldSpec : Ident",
+"FieldSpec : Element",
+"Element : ACTION_TOK",
+"Element : INTERPRET",
+"Element : TYPE",
+"Element : KEY",
+"Element : GROUP",
+"Element : MODIFIER_MAP",
+"Element : INDICATOR",
+"Element : SHAPE",
+"Element : ROW",
+"Element : SECTION",
+"Element : TEXT",
+"OptMergeMode : MergeMode",
+"OptMergeMode :",
+"MergeMode : INCLUDE",
+"MergeMode : AUGMENT",
+"MergeMode : OVERRIDE",
+"MergeMode : REPLACE",
+"MergeMode : ALTERNATE",
+"OptExprList : ExprList",
+"OptExprList :",
+"ExprList : ExprList COMMA Expr",
+"ExprList : Expr",
+"Expr : Expr DIVIDE Expr",
+"Expr : Expr PLUS Expr",
+"Expr : Expr MINUS Expr",
+"Expr : Expr TIMES Expr",
+"Expr : Lhs EQUALS Expr",
+"Expr : Term",
+"Term : MINUS Term",
+"Term : PLUS Term",
+"Term : EXCLAM Term",
+"Term : INVERT Term",
+"Term : Lhs",
+"Term : FieldSpec OPAREN OptExprList CPAREN",
+"Term : Terminal",
+"Term : OPAREN Expr CPAREN",
+"ActionList : ActionList COMMA Action",
+"ActionList : Action",
+"Action : FieldSpec OPAREN OptExprList CPAREN",
+"Lhs : FieldSpec",
+"Lhs : FieldSpec DOT FieldSpec",
+"Lhs : FieldSpec OBRACKET Expr CBRACKET",
+"Lhs : FieldSpec DOT FieldSpec OBRACKET Expr CBRACKET",
+"Terminal : String",
+"Terminal : Integer",
+"Terminal : Float",
+"Terminal : KEYNAME",
+"OptKeySymList : KeySymList",
+"OptKeySymList :",
+"KeySymList : KeySymList COMMA KeySym",
+"KeySymList : KeySymList COMMA KeySyms",
+"KeySymList : KeySym",
+"KeySymList : KeySyms",
+"KeySyms : OBRACE KeySymList CBRACE",
+"KeySym : IDENT",
+"KeySym : SECTION",
+"KeySym : Integer",
+"SignedNumber : MINUS Number",
+"SignedNumber : Number",
+"Number : FLOAT",
+"Number : INTEGER",
+"Float : FLOAT",
+"Integer : INTEGER",
+"KeyCode : INTEGER",
+"Ident : IDENT",
+"Ident : DEFAULT",
+"String : STRING",
+"OptMapName : MapName",
+"OptMapName :",
+"MapName : STRING",
+
+};
+#endif
+
+#if YYDEBUG
+int      yydebug;
+#endif
+
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+#ifndef YYLLOC_DEFAULT
+#define YYLLOC_DEFAULT(loc, rhs, n) \
+do \
+{ \
+    if (n == 0) \
+    { \
+        (loc).first_line   = YYRHSLOC(rhs, 0).last_line; \
+        (loc).first_column = YYRHSLOC(rhs, 0).last_column; \
+        (loc).last_line    = YYRHSLOC(rhs, 0).last_line; \
+        (loc).last_column  = YYRHSLOC(rhs, 0).last_column; \
+    } \
+    else \
+    { \
+        (loc).first_line   = YYRHSLOC(rhs, 1).first_line; \
+        (loc).first_column = YYRHSLOC(rhs, 1).first_column; \
+        (loc).last_line    = YYRHSLOC(rhs, n).last_line; \
+        (loc).last_column  = YYRHSLOC(rhs, n).last_column; \
+    } \
+} while (0)
+#endif /* YYLLOC_DEFAULT */
+#endif /* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
+#if YYBTYACC
+
+#ifndef YYLVQUEUEGROWTH
+#define YYLVQUEUEGROWTH 32
+#endif
+#endif /* YYBTYACC */
+
+/* define the initial stack-sizes */
+#ifdef YYSTACKSIZE
+#undef YYMAXDEPTH
+#define YYMAXDEPTH  YYSTACKSIZE
+#else
+#ifdef YYMAXDEPTH
+#define YYSTACKSIZE YYMAXDEPTH
+#else
+#define YYSTACKSIZE 10000
+#define YYMAXDEPTH  10000
+#endif
+#endif
+
+#ifndef YYINITSTACKSIZE
+#define YYINITSTACKSIZE 200
+#endif
+
+typedef struct {
+    unsigned stacksize;
+    YYINT    *s_base;
+    YYINT    *s_mark;
+    YYINT    *s_last;
+    YYSTYPE  *l_base;
+    YYSTYPE  *l_mark;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    YYLTYPE  *p_base;
+    YYLTYPE  *p_mark;
+#endif
+} YYSTACKDATA;
+#if YYBTYACC
+
+struct YYParseState_s
+{
+    struct YYParseState_s *save;    /* Previously saved parser state */
+    YYSTACKDATA            yystack; /* saved parser stack */
+    int                    state;   /* saved parser state */
+    int                    errflag; /* saved error recovery status */
+    int                    lexeme;  /* saved index of the conflict lexeme in the lexical queue */
+    YYINT                  ctry;    /* saved index in yyctable[] for this conflict */
+};
+typedef struct YYParseState_s YYParseState;
+#endif /* YYBTYACC */
+#line 808 "parser.y"
+
+XkbFile *
+parse(struct xkb_context *ctx, struct scanner *scanner, const char *map)
+{
+    int ret;
+    XkbFile *first = NULL;
+    struct parser_param param = {
+        .scanner = scanner,
+        .ctx = ctx,
+        .rtrn = NULL,
+        .more_maps = false,
+    };
+
+    /*
+     * If we got a specific map, we look for it exclusively and return
+     * immediately upon finding it. Otherwise, we need to get the
+     * default map. If we find a map marked as default, we return it
+     * immediately. If there are no maps marked as default, we return
+     * the first map in the file.
+     */
+
+    while ((ret = yyparse(&param)) == 0 && param.more_maps) {
+        if (map) {
+            if (streq_not_null(map, param.rtrn->name))
+                return param.rtrn;
+            else
+                FreeXkbFile(param.rtrn);
+        }
+        else {
+            if (param.rtrn->flags & MAP_IS_DEFAULT) {
+                FreeXkbFile(first);
+                return param.rtrn;
+            }
+            else if (!first) {
+                first = param.rtrn;
+            }
+            else {
+                FreeXkbFile(param.rtrn);
+            }
+        }
+        param.rtrn = NULL;
+    }
+
+    if (ret != 0) {
+        FreeXkbFile(first);
+        return NULL;
+    }
+
+    if (first)
+        log_vrb(ctx, 5,
+                XKB_WARNING_MISSING_DEFAULT_SECTION,
+                "No map in include statement, but \"%s\" contains several; "
+                "Using first defined map, \"%s\"\n",
+                scanner->file_name, first->name);
+
+    return first;
+}
+#line 1192 "parser.c"
+
+/* Release memory associated with symbol. */
+#if ! defined YYDESTRUCT_IS_DECLARED
+static void
+YYDESTRUCT_DECL()
+{
+    switch (psymb)
+    {
+	case 60:
+#line 239 "parser.y"
+	{ free((*val).str); }
+#line 1204 "parser.c"
+	break;
+	case 63:
+#line 239 "parser.y"
+	{ free((*val).str); }
+#line 1209 "parser.c"
+	break;
+	case 258:
+#line 237 "parser.y"
+	{ if (!param->rtrn) FreeXkbFile((*val).file); }
+#line 1214 "parser.c"
+	break;
+	case 272:
+#line 239 "parser.y"
+	{ free((*val).str); }
+#line 1219 "parser.c"
+	break;
+	case 273:
+#line 239 "parser.y"
+	{ free((*val).str); }
+#line 1224 "parser.c"
+	break;
+	case 279:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).any); }
+#line 1229 "parser.c"
+	break;
+	case 280:
+#line 233 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).anyList.head); }
+#line 1234 "parser.c"
+	break;
+	case 281:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).expr); }
+#line 1239 "parser.c"
+	break;
+	case 282:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).expr); }
+#line 1244 "parser.c"
+	break;
+	case 283:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).expr); }
+#line 1249 "parser.c"
+	break;
+	case 284:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).expr); }
+#line 1254 "parser.c"
+	break;
+	case 285:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).expr); }
+#line 1259 "parser.c"
+	break;
+	case 286:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).expr); }
+#line 1264 "parser.c"
+	break;
+	case 287:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).expr); }
+#line 1269 "parser.c"
+	break;
+	case 288:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).expr); }
+#line 1274 "parser.c"
+	break;
+	case 289:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).expr); }
+#line 1279 "parser.c"
+	break;
+	case 290:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).expr); }
+#line 1284 "parser.c"
+	break;
+	case 291:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).expr); }
+#line 1289 "parser.c"
+	break;
+	case 292:
+#line 233 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).exprList.head); }
+#line 1294 "parser.c"
+	break;
+	case 293:
+#line 233 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).exprList.head); }
+#line 1299 "parser.c"
+	break;
+	case 294:
+#line 233 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).exprList.head); }
+#line 1304 "parser.c"
+	break;
+	case 295:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).var); }
+#line 1309 "parser.c"
+	break;
+	case 296:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).var); }
+#line 1314 "parser.c"
+	break;
+	case 297:
+#line 233 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).varList.head); }
+#line 1319 "parser.c"
+	break;
+	case 298:
+#line 233 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).varList.head); }
+#line 1324 "parser.c"
+	break;
+	case 299:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).vmod); }
+#line 1329 "parser.c"
+	break;
+	case 300:
+#line 233 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).vmodList.head); }
+#line 1334 "parser.c"
+	break;
+	case 301:
+#line 233 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).vmodList.head); }
+#line 1339 "parser.c"
+	break;
+	case 302:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).interp); }
+#line 1344 "parser.c"
+	break;
+	case 303:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).interp); }
+#line 1349 "parser.c"
+	break;
+	case 304:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).keyType); }
+#line 1354 "parser.c"
+	break;
+	case 305:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).syms); }
+#line 1359 "parser.c"
+	break;
+	case 306:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).modMask); }
+#line 1364 "parser.c"
+	break;
+	case 307:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).groupCompat); }
+#line 1369 "parser.c"
+	break;
+	case 308:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).ledMap); }
+#line 1374 "parser.c"
+	break;
+	case 309:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).ledName); }
+#line 1379 "parser.c"
+	break;
+	case 310:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).keyCode); }
+#line 1384 "parser.c"
+	break;
+	case 311:
+#line 230 "parser.y"
+	{ FreeStmt((ParseCommon *) (*val).keyAlias); }
+#line 1389 "parser.c"
+	break;
+	case 326:
+#line 237 "parser.y"
+	{ if (!param->rtrn) FreeXkbFile((*val).file); }
+#line 1394 "parser.c"
+	break;
+	case 327:
+#line 238 "parser.y"
+	{ FreeXkbFile((*val).fileList.head); }
+#line 1399 "parser.c"
+	break;
+	case 328:
+#line 237 "parser.y"
+	{ if (!param->rtrn) FreeXkbFile((*val).file); }
+#line 1404 "parser.c"
+	break;
+    }
+}
+#define YYDESTRUCT_IS_DECLARED 1
+#endif
+
+/* For use in generated program */
+#define yydepth (int)(yystack.s_mark - yystack.s_base)
+#if YYBTYACC
+#define yytrial (yyps->save)
+#endif /* YYBTYACC */
+
+#if YYDEBUG
+#include <stdio.h>	/* needed for printf */
+#endif
+
+#include <stdlib.h>	/* needed for malloc, etc */
+#include <string.h>	/* needed for memset */
+
+/* allocate initial stack or double stack size, up to YYMAXDEPTH */
+static int yygrowstack(YYSTACKDATA *data)
+{
+    int i;
+    unsigned newsize;
+    YYINT *newss;
+    YYSTYPE *newvs;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    YYLTYPE *newps;
+#endif
+
+    if ((newsize = data->stacksize) == 0)
+        newsize = YYINITSTACKSIZE;
+    else if (newsize >= YYMAXDEPTH)
+        return YYENOMEM;
+    else if ((newsize *= 2) > YYMAXDEPTH)
+        newsize = YYMAXDEPTH;
+
+    i = (int) (data->s_mark - data->s_base);
+    newss = (YYINT *)realloc(data->s_base, newsize * sizeof(*newss));
+    if (newss == 0)
+        return YYENOMEM;
+
+    data->s_base = newss;
+    data->s_mark = newss + i;
+
+    newvs = (YYSTYPE *)realloc(data->l_base, newsize * sizeof(*newvs));
+    if (newvs == 0)
+        return YYENOMEM;
+
+    data->l_base = newvs;
+    data->l_mark = newvs + i;
+
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    newps = (YYLTYPE *)realloc(data->p_base, newsize * sizeof(*newps));
+    if (newps == 0)
+        return YYENOMEM;
+
+    data->p_base = newps;
+    data->p_mark = newps + i;
+#endif
+
+    data->stacksize = newsize;
+    data->s_last = data->s_base + newsize - 1;
+
+#if YYDEBUG
+    if (yydebug)
+        fprintf(stderr, "%sdebug: stack size increased to %d\n", YYPREFIX, newsize);
+#endif
+    return 0;
+}
+
+#if YYPURE || defined(YY_NO_LEAKS)
+static void yyfreestack(YYSTACKDATA *data)
+{
+    free(data->s_base);
+    free(data->l_base);
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    free(data->p_base);
+#endif
+    memset(data, 0, sizeof(*data));
+}
+#else
+#define yyfreestack(data) /* nothing */
+#endif /* YYPURE || defined(YY_NO_LEAKS) */
+#if YYBTYACC
+
+static YYParseState *
+yyNewState(unsigned size)
+{
+    YYParseState *p = (YYParseState *) malloc(sizeof(YYParseState));
+    if (p == NULL) return NULL;
+
+    p->yystack.stacksize = size;
+    if (size == 0)
+    {
+        p->yystack.s_base = NULL;
+        p->yystack.l_base = NULL;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+        p->yystack.p_base = NULL;
+#endif
+        return p;
+    }
+    p->yystack.s_base    = (YYINT *) malloc(size * sizeof(YYINT));
+    if (p->yystack.s_base == NULL) return NULL;
+    p->yystack.l_base    = (YYSTYPE *) malloc(size * sizeof(YYSTYPE));
+    if (p->yystack.l_base == NULL) return NULL;
+    memset(p->yystack.l_base, 0, size * sizeof(YYSTYPE));
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    p->yystack.p_base    = (YYLTYPE *) malloc(size * sizeof(YYLTYPE));
+    if (p->yystack.p_base == NULL) return NULL;
+    memset(p->yystack.p_base, 0, size * sizeof(YYLTYPE));
+#endif
+
+    return p;
+}
+
+static void
+yyFreeState(YYParseState *p)
+{
+    yyfreestack(&p->yystack);
+    free(p);
+}
+#endif /* YYBTYACC */
+
+#define YYABORT  goto yyabort
+#define YYREJECT goto yyabort
+#define YYACCEPT goto yyaccept
+#define YYERROR  goto yyerrlab
+#if YYBTYACC
+#define YYVALID        do { if (yyps->save)            goto yyvalid; } while(0)
+#define YYVALID_NESTED do { if (yyps->save && \
+                                yyps->save->save == 0) goto yyvalid; } while(0)
+#endif /* YYBTYACC */
+
+int
+YYPARSE_DECL()
+{
+    int      yyerrflag;
+    int      yychar;
+    YYSTYPE  yyval;
+    YYSTYPE  yylval;
+    int      yynerrs;
+
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    YYLTYPE  yyloc; /* position returned by actions */
+    YYLTYPE  yylloc; /* position from the lexer */
+#endif
+
+    /* variables for the parser stack */
+    YYSTACKDATA yystack;
+#if YYBTYACC
+
+    /* Current parser state */
+    static YYParseState *yyps = 0;
+
+    /* yypath != NULL: do the full parse, starting at *yypath parser state. */
+    static YYParseState *yypath = 0;
+
+    /* Base of the lexical value queue */
+    static YYSTYPE *yylvals = 0;
+
+    /* Current position at lexical value queue */
+    static YYSTYPE *yylvp = 0;
+
+    /* End position of lexical value queue */
+    static YYSTYPE *yylve = 0;
+
+    /* The last allocated position at the lexical value queue */
+    static YYSTYPE *yylvlim = 0;
+
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    /* Base of the lexical position queue */
+    static YYLTYPE *yylpsns = 0;
+
+    /* Current position at lexical position queue */
+    static YYLTYPE *yylpp = 0;
+
+    /* End position of lexical position queue */
+    static YYLTYPE *yylpe = 0;
+
+    /* The last allocated position at the lexical position queue */
+    static YYLTYPE *yylplim = 0;
+#endif
+
+    /* Current position at lexical token queue */
+    static YYINT  *yylexp = 0;
+
+    static YYINT  *yylexemes = 0;
+#endif /* YYBTYACC */
+    int yym, yyn, yystate, yyresult;
+#if YYBTYACC
+    int yynewerrflag;
+    YYParseState *yyerrctx = NULL;
+#endif /* YYBTYACC */
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    YYLTYPE  yyerror_loc_range[3]; /* position of error start/end (0 unused) */
+#endif
+#if YYDEBUG
+    const char *yys;
+
+    if ((yys = getenv("YYDEBUG")) != 0)
+    {
+        yyn = *yys;
+        if (yyn >= '0' && yyn <= '9')
+            yydebug = yyn - '0';
+    }
+    if (yydebug)
+        fprintf(stderr, "%sdebug[<# of symbols on state stack>]\n", YYPREFIX);
+#endif
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    memset(yyerror_loc_range, 0, sizeof(yyerror_loc_range));
+#endif
+
+    yyerrflag = 0;
+    yychar = 0;
+    memset(&yyval,  0, sizeof(yyval));
+    memset(&yylval, 0, sizeof(yylval));
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    memset(&yyloc,  0, sizeof(yyloc));
+    memset(&yylloc, 0, sizeof(yylloc));
+#endif
+
+#if YYBTYACC
+    yyps = yyNewState(0); if (yyps == 0) goto yyenomem;
+    yyps->save = 0;
+#endif /* YYBTYACC */
+    yym = 0;
+    /* yyn is set below */
+    yynerrs = 0;
+    yyerrflag = 0;
+    yychar = YYEMPTY;
+    yystate = 0;
+
+#if YYPURE
+    memset(&yystack, 0, sizeof(yystack));
+#endif
+
+    if (yystack.s_base == NULL && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
+    yystack.s_mark = yystack.s_base;
+    yystack.l_mark = yystack.l_base;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    yystack.p_mark = yystack.p_base;
+#endif
+    yystate = 0;
+    *yystack.s_mark = 0;
+
+yyloop:
+    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
+    if (yychar < 0)
+    {
+#if YYBTYACC
+        do {
+        if (yylvp < yylve)
+        {
+            /* we're currently re-reading tokens */
+            yylval = *yylvp++;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+            yylloc = *yylpp++;
+#endif
+            yychar = *yylexp++;
+            break;
+        }
+        if (yyps->save)
+        {
+            /* in trial mode; save scanner results for future parse attempts */
+            if (yylvp == yylvlim)
+            {   /* Enlarge lexical value queue */
+                size_t p = (size_t) (yylvp - yylvals);
+                size_t s = (size_t) (yylvlim - yylvals);
+
+                s += YYLVQUEUEGROWTH;
+                if ((yylexemes = (YYINT *)realloc(yylexemes, s * sizeof(YYINT))) == NULL) goto yyenomem;
+                if ((yylvals   = (YYSTYPE *)realloc(yylvals, s * sizeof(YYSTYPE))) == NULL) goto yyenomem;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                if ((yylpsns   = (YYLTYPE *)realloc(yylpsns, s * sizeof(YYLTYPE))) == NULL) goto yyenomem;
+#endif
+                yylvp   = yylve = yylvals + p;
+                yylvlim = yylvals + s;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                yylpp   = yylpe = yylpsns + p;
+                yylplim = yylpsns + s;
+#endif
+                yylexp  = yylexemes + p;
+            }
+            *yylexp = (YYINT) YYLEX;
+            *yylvp++ = yylval;
+            yylve++;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+            *yylpp++ = yylloc;
+            yylpe++;
+#endif
+            yychar = *yylexp++;
+            break;
+        }
+        /* normal operation, no conflict encountered */
+#endif /* YYBTYACC */
+        yychar = YYLEX;
+#if YYBTYACC
+        } while (0);
+#endif /* YYBTYACC */
+        if (yychar < 0) yychar = YYEOF;
+#if YYDEBUG
+        if (yydebug)
+        {
+            if ((yys = yyname[YYTRANSLATE(yychar)]) == NULL) yys = yyname[YYUNDFTOKEN];
+            fprintf(stderr, "%s[%d]: state %d, reading token %d (%s)",
+                            YYDEBUGSTR, yydepth, yystate, yychar, yys);
+#ifdef YYSTYPE_TOSTRING
+#if YYBTYACC
+            if (!yytrial)
+#endif /* YYBTYACC */
+                fprintf(stderr, " <%s>", YYSTYPE_TOSTRING(yychar, yylval));
+#endif
+            fputc('\n', stderr);
+        }
+#endif
+    }
+#if YYBTYACC
+
+    /* Do we have a conflict? */
+    if (((yyn = yycindex[yystate]) != 0) && (yyn += yychar) >= 0 &&
+        yyn <= YYTABLESIZE && yycheck[yyn] == (YYINT) yychar)
+    {
+        YYINT ctry;
+
+        if (yypath)
+        {
+            YYParseState *save;
+#if YYDEBUG
+            if (yydebug)
+                fprintf(stderr, "%s[%d]: CONFLICT in state %d: following successful trial parse\n",
+                                YYDEBUGSTR, yydepth, yystate);
+#endif
+            /* Switch to the next conflict context */
+            save = yypath;
+            yypath = save->save;
+            save->save = NULL;
+            ctry = save->ctry;
+            if (save->state != yystate) YYABORT;
+            yyFreeState(save);
+
+        }
+        else
+        {
+
+            /* Unresolved conflict - start/continue trial parse */
+            YYParseState *save;
+#if YYDEBUG
+            if (yydebug)
+            {
+                fprintf(stderr, "%s[%d]: CONFLICT in state %d. ", YYDEBUGSTR, yydepth, yystate);
+                if (yyps->save)
+                    fputs("ALREADY in conflict, continuing trial parse.\n", stderr);
+                else
+                    fputs("Starting trial parse.\n", stderr);
+            }
+#endif
+            save                  = yyNewState((unsigned)(yystack.s_mark - yystack.s_base + 1));
+            if (save == NULL) goto yyenomem;
+            save->save            = yyps->save;
+            save->state           = yystate;
+            save->errflag         = yyerrflag;
+            save->yystack.s_mark  = save->yystack.s_base + (yystack.s_mark - yystack.s_base);
+            memcpy (save->yystack.s_base, yystack.s_base, (size_t) (yystack.s_mark - yystack.s_base + 1) * sizeof(YYINT));
+            save->yystack.l_mark  = save->yystack.l_base + (yystack.l_mark - yystack.l_base);
+            memcpy (save->yystack.l_base, yystack.l_base, (size_t) (yystack.l_mark - yystack.l_base + 1) * sizeof(YYSTYPE));
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+            save->yystack.p_mark  = save->yystack.p_base + (yystack.p_mark - yystack.p_base);
+            memcpy (save->yystack.p_base, yystack.p_base, (size_t) (yystack.p_mark - yystack.p_base + 1) * sizeof(YYLTYPE));
+#endif
+            ctry                  = yytable[yyn];
+            if (yyctable[ctry] == -1)
+            {
+#if YYDEBUG
+                if (yydebug && yychar >= YYEOF)
+                    fprintf(stderr, "%s[%d]: backtracking 1 token\n", YYDEBUGSTR, yydepth);
+#endif
+                ctry++;
+            }
+            save->ctry = ctry;
+            if (yyps->save == NULL)
+            {
+                /* If this is a first conflict in the stack, start saving lexemes */
+                if (!yylexemes)
+                {
+                    yylexemes = (YYINT *) malloc((YYLVQUEUEGROWTH) * sizeof(YYINT));
+                    if (yylexemes == NULL) goto yyenomem;
+                    yylvals   = (YYSTYPE *) malloc((YYLVQUEUEGROWTH) * sizeof(YYSTYPE));
+                    if (yylvals == NULL) goto yyenomem;
+                    yylvlim   = yylvals + YYLVQUEUEGROWTH;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                    yylpsns   = (YYLTYPE *) malloc((YYLVQUEUEGROWTH) * sizeof(YYLTYPE));
+                    if (yylpsns == NULL) goto yyenomem;
+                    yylplim   = yylpsns + YYLVQUEUEGROWTH;
+#endif
+                }
+                if (yylvp == yylve)
+                {
+                    yylvp  = yylve = yylvals;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                    yylpp  = yylpe = yylpsns;
+#endif
+                    yylexp = yylexemes;
+                    if (yychar >= YYEOF)
+                    {
+                        *yylve++ = yylval;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                        *yylpe++ = yylloc;
+#endif
+                        *yylexp  = (YYINT) yychar;
+                        yychar   = YYEMPTY;
+                    }
+                }
+            }
+            if (yychar >= YYEOF)
+            {
+                yylvp--;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                yylpp--;
+#endif
+                yylexp--;
+                yychar = YYEMPTY;
+            }
+            save->lexeme = (int) (yylvp - yylvals);
+            yyps->save   = save;
+        }
+        if (yytable[yyn] == ctry)
+        {
+#if YYDEBUG
+            if (yydebug)
+                fprintf(stderr, "%s[%d]: state %d, shifting to state %d\n",
+                                YYDEBUGSTR, yydepth, yystate, yyctable[ctry]);
+#endif
+            if (yychar < 0)
+            {
+                yylvp++;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                yylpp++;
+#endif
+                yylexp++;
+            }
+            if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
+                goto yyoverflow;
+            yystate = yyctable[ctry];
+            *++yystack.s_mark = (YYINT) yystate;
+            *++yystack.l_mark = yylval;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+            *++yystack.p_mark = yylloc;
+#endif
+            yychar  = YYEMPTY;
+            if (yyerrflag > 0) --yyerrflag;
+            goto yyloop;
+        }
+        else
+        {
+            yyn = yyctable[ctry];
+            goto yyreduce;
+        }
+    } /* End of code dealing with conflicts */
+#endif /* YYBTYACC */
+    if (((yyn = yysindex[yystate]) != 0) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == (YYINT) yychar)
+    {
+#if YYDEBUG
+        if (yydebug)
+            fprintf(stderr, "%s[%d]: state %d, shifting to state %d\n",
+                            YYDEBUGSTR, yydepth, yystate, yytable[yyn]);
+#endif
+        if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
+        yystate = yytable[yyn];
+        *++yystack.s_mark = yytable[yyn];
+        *++yystack.l_mark = yylval;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+        *++yystack.p_mark = yylloc;
+#endif
+        yychar = YYEMPTY;
+        if (yyerrflag > 0)  --yyerrflag;
+        goto yyloop;
+    }
+    if (((yyn = yyrindex[yystate]) != 0) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == (YYINT) yychar)
+    {
+        yyn = yytable[yyn];
+        goto yyreduce;
+    }
+    if (yyerrflag != 0) goto yyinrecovery;
+#if YYBTYACC
+
+    yynewerrflag = 1;
+    goto yyerrhandler;
+    goto yyerrlab; /* redundant goto avoids 'unused label' warning */
+
+yyerrlab:
+    /* explicit YYERROR from an action -- pop the rhs of the rule reduced
+     * before looking for error recovery */
+    yystack.s_mark -= yym;
+    yystate = *yystack.s_mark;
+    yystack.l_mark -= yym;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    yystack.p_mark -= yym;
+#endif
+
+    yynewerrflag = 0;
+yyerrhandler:
+    while (yyps->save)
+    {
+        int ctry;
+        YYParseState *save = yyps->save;
+#if YYDEBUG
+        if (yydebug)
+            fprintf(stderr, "%s[%d]: ERROR in state %d, CONFLICT BACKTRACKING to state %d, %d tokens\n",
+                            YYDEBUGSTR, yydepth, yystate, yyps->save->state,
+                    (int)(yylvp - yylvals - yyps->save->lexeme));
+#endif
+        /* Memorize most forward-looking error state in case it's really an error. */
+        if (yyerrctx == NULL || yyerrctx->lexeme < yylvp - yylvals)
+        {
+            /* Free old saved error context state */
+            if (yyerrctx) yyFreeState(yyerrctx);
+            /* Create and fill out new saved error context state */
+            yyerrctx                 = yyNewState((unsigned)(yystack.s_mark - yystack.s_base + 1));
+            if (yyerrctx == NULL) goto yyenomem;
+            yyerrctx->save           = yyps->save;
+            yyerrctx->state          = yystate;
+            yyerrctx->errflag        = yyerrflag;
+            yyerrctx->yystack.s_mark = yyerrctx->yystack.s_base + (yystack.s_mark - yystack.s_base);
+            memcpy (yyerrctx->yystack.s_base, yystack.s_base, (size_t) (yystack.s_mark - yystack.s_base + 1) * sizeof(YYINT));
+            yyerrctx->yystack.l_mark = yyerrctx->yystack.l_base + (yystack.l_mark - yystack.l_base);
+            memcpy (yyerrctx->yystack.l_base, yystack.l_base, (size_t) (yystack.l_mark - yystack.l_base + 1) * sizeof(YYSTYPE));
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+            yyerrctx->yystack.p_mark = yyerrctx->yystack.p_base + (yystack.p_mark - yystack.p_base);
+            memcpy (yyerrctx->yystack.p_base, yystack.p_base, (size_t) (yystack.p_mark - yystack.p_base + 1) * sizeof(YYLTYPE));
+#endif
+            yyerrctx->lexeme         = (int) (yylvp - yylvals);
+        }
+        yylvp          = yylvals   + save->lexeme;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+        yylpp          = yylpsns   + save->lexeme;
+#endif
+        yylexp         = yylexemes + save->lexeme;
+        yychar         = YYEMPTY;
+        yystack.s_mark = yystack.s_base + (save->yystack.s_mark - save->yystack.s_base);
+        memcpy (yystack.s_base, save->yystack.s_base, (size_t) (yystack.s_mark - yystack.s_base + 1) * sizeof(YYINT));
+        yystack.l_mark = yystack.l_base + (save->yystack.l_mark - save->yystack.l_base);
+        memcpy (yystack.l_base, save->yystack.l_base, (size_t) (yystack.l_mark - yystack.l_base + 1) * sizeof(YYSTYPE));
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+        yystack.p_mark = yystack.p_base + (save->yystack.p_mark - save->yystack.p_base);
+        memcpy (yystack.p_base, save->yystack.p_base, (size_t) (yystack.p_mark - yystack.p_base + 1) * sizeof(YYLTYPE));
+#endif
+        ctry           = ++save->ctry;
+        yystate        = save->state;
+        /* We tried shift, try reduce now */
+        if ((yyn = yyctable[ctry]) >= 0) goto yyreduce;
+        yyps->save     = save->save;
+        save->save     = NULL;
+        yyFreeState(save);
+
+        /* Nothing left on the stack -- error */
+        if (!yyps->save)
+        {
+#if YYDEBUG
+            if (yydebug)
+                fprintf(stderr, "%sdebug[%d,trial]: trial parse FAILED, entering ERROR mode\n",
+                                YYPREFIX, yydepth);
+#endif
+            /* Restore state as it was in the most forward-advanced error */
+            yylvp          = yylvals   + yyerrctx->lexeme;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+            yylpp          = yylpsns   + yyerrctx->lexeme;
+#endif
+            yylexp         = yylexemes + yyerrctx->lexeme;
+            yychar         = yylexp[-1];
+            yylval         = yylvp[-1];
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+            yylloc         = yylpp[-1];
+#endif
+            yystack.s_mark = yystack.s_base + (yyerrctx->yystack.s_mark - yyerrctx->yystack.s_base);
+            memcpy (yystack.s_base, yyerrctx->yystack.s_base, (size_t) (yystack.s_mark - yystack.s_base + 1) * sizeof(YYINT));
+            yystack.l_mark = yystack.l_base + (yyerrctx->yystack.l_mark - yyerrctx->yystack.l_base);
+            memcpy (yystack.l_base, yyerrctx->yystack.l_base, (size_t) (yystack.l_mark - yystack.l_base + 1) * sizeof(YYSTYPE));
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+            yystack.p_mark = yystack.p_base + (yyerrctx->yystack.p_mark - yyerrctx->yystack.p_base);
+            memcpy (yystack.p_base, yyerrctx->yystack.p_base, (size_t) (yystack.p_mark - yystack.p_base + 1) * sizeof(YYLTYPE));
+#endif
+            yystate        = yyerrctx->state;
+            yyFreeState(yyerrctx);
+            yyerrctx       = NULL;
+        }
+        yynewerrflag = 1;
+    }
+    if (yynewerrflag == 0) goto yyinrecovery;
+#endif /* YYBTYACC */
+
+    YYERROR_CALL("syntax error");
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    yyerror_loc_range[1] = yylloc; /* lookahead position is error start position */
+#endif
+
+#if !YYBTYACC
+    goto yyerrlab; /* redundant goto avoids 'unused label' warning */
+yyerrlab:
+#endif
+    ++yynerrs;
+
+yyinrecovery:
+    if (yyerrflag < 3)
+    {
+        yyerrflag = 3;
+        for (;;)
+        {
+            if (((yyn = yysindex[*yystack.s_mark]) != 0) && (yyn += YYERRCODE) >= 0 &&
+                    yyn <= YYTABLESIZE && yycheck[yyn] == (YYINT) YYERRCODE)
+            {
+#if YYDEBUG
+                if (yydebug)
+                    fprintf(stderr, "%s[%d]: state %d, error recovery shifting to state %d\n",
+                                    YYDEBUGSTR, yydepth, *yystack.s_mark, yytable[yyn]);
+#endif
+                if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
+                yystate = yytable[yyn];
+                *++yystack.s_mark = yytable[yyn];
+                *++yystack.l_mark = yylval;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                /* lookahead position is error end position */
+                yyerror_loc_range[2] = yylloc;
+                YYLLOC_DEFAULT(yyloc, yyerror_loc_range, 2); /* position of error span */
+                *++yystack.p_mark = yyloc;
+#endif
+                goto yyloop;
+            }
+            else
+            {
+#if YYDEBUG
+                if (yydebug)
+                    fprintf(stderr, "%s[%d]: error recovery discarding state %d\n",
+                                    YYDEBUGSTR, yydepth, *yystack.s_mark);
+#endif
+                if (yystack.s_mark <= yystack.s_base) goto yyabort;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                /* the current TOS position is the error start position */
+                yyerror_loc_range[1] = *yystack.p_mark;
+#endif
+#if defined(YYDESTRUCT_CALL)
+#if YYBTYACC
+                if (!yytrial)
+#endif /* YYBTYACC */
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                    YYDESTRUCT_CALL("error: discarding state",
+                                    yystos[*yystack.s_mark], yystack.l_mark, yystack.p_mark);
+#else
+                    YYDESTRUCT_CALL("error: discarding state",
+                                    yystos[*yystack.s_mark], yystack.l_mark);
+#endif /* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
+#endif /* defined(YYDESTRUCT_CALL) */
+                --yystack.s_mark;
+                --yystack.l_mark;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                --yystack.p_mark;
+#endif
+            }
+        }
+    }
+    else
+    {
+        if (yychar == YYEOF) goto yyabort;
+#if YYDEBUG
+        if (yydebug)
+        {
+            if ((yys = yyname[YYTRANSLATE(yychar)]) == NULL) yys = yyname[YYUNDFTOKEN];
+            fprintf(stderr, "%s[%d]: state %d, error recovery discarding token %d (%s)\n",
+                            YYDEBUGSTR, yydepth, yystate, yychar, yys);
+        }
+#endif
+#if defined(YYDESTRUCT_CALL)
+#if YYBTYACC
+        if (!yytrial)
+#endif /* YYBTYACC */
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+            YYDESTRUCT_CALL("error: discarding token", yychar, &yylval, &yylloc);
+#else
+            YYDESTRUCT_CALL("error: discarding token", yychar, &yylval);
+#endif /* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
+#endif /* defined(YYDESTRUCT_CALL) */
+        yychar = YYEMPTY;
+        goto yyloop;
+    }
+
+yyreduce:
+    yym = yylen[yyn];
+#if YYDEBUG
+    if (yydebug)
+    {
+        fprintf(stderr, "%s[%d]: state %d, reducing by rule %d (%s)",
+                        YYDEBUGSTR, yydepth, yystate, yyn, yyrule[yyn]);
+#ifdef YYSTYPE_TOSTRING
+#if YYBTYACC
+        if (!yytrial)
+#endif /* YYBTYACC */
+            if (yym > 0)
+            {
+                int i;
+                fputc('<', stderr);
+                for (i = yym; i > 0; i--)
+                {
+                    if (i != yym) fputs(", ", stderr);
+                    fputs(YYSTYPE_TOSTRING(yystos[yystack.s_mark[1-i]],
+                                           yystack.l_mark[1-i]), stderr);
+                }
+                fputc('>', stderr);
+            }
+#endif
+        fputc('\n', stderr);
+    }
+#endif
+    if (yym > 0)
+        yyval = yystack.l_mark[1-yym];
+    else
+        memset(&yyval, 0, sizeof yyval);
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+
+    /* Perform position reduction */
+    memset(&yyloc, 0, sizeof(yyloc));
+#if YYBTYACC
+    if (!yytrial)
+#endif /* YYBTYACC */
+    {
+        YYLLOC_DEFAULT(yyloc, &yystack.p_mark[-yym], yym);
+        /* just in case YYERROR is invoked within the action, save
+           the start of the rhs as the error start position */
+        yyerror_loc_range[1] = yystack.p_mark[1-yym];
+    }
+#endif
+
+    switch (yyn)
+    {
+case 1:
+#line 256 "parser.y"
+	{ yyval.file = param->rtrn = yystack.l_mark[0].file; param->more_maps = !!param->rtrn; }
+#line 2143 "parser.c"
+break;
+case 2:
+#line 258 "parser.y"
+	{ yyval.file = param->rtrn = yystack.l_mark[0].file; param->more_maps = !!param->rtrn; YYACCEPT; }
+#line 2148 "parser.c"
+break;
+case 3:
+#line 260 "parser.y"
+	{ yyval.file = param->rtrn = NULL; param->more_maps = false; }
+#line 2153 "parser.c"
+break;
+case 4:
+#line 266 "parser.y"
+	{ yyval.file = XkbFileCreate(yystack.l_mark[-5].file_type, yystack.l_mark[-4].str, (ParseCommon *) yystack.l_mark[-2].fileList.head, yystack.l_mark[-6].mapFlags); }
+#line 2158 "parser.c"
+break;
+case 5:
+#line 269 "parser.y"
+	{ yyval.file_type = FILE_TYPE_KEYMAP; }
+#line 2163 "parser.c"
+break;
+case 6:
+#line 270 "parser.y"
+	{ yyval.file_type = FILE_TYPE_KEYMAP; }
+#line 2168 "parser.c"
+break;
+case 7:
+#line 271 "parser.y"
+	{ yyval.file_type = FILE_TYPE_KEYMAP; }
+#line 2173 "parser.c"
+break;
+case 8:
+#line 275 "parser.y"
+	{ yyval.fileList.head = yystack.l_mark[-1].fileList.head; yyval.fileList.last->common.next = &yystack.l_mark[0].file->common; yyval.fileList.last = yystack.l_mark[0].file; }
+#line 2178 "parser.c"
+break;
+case 9:
+#line 277 "parser.y"
+	{ yyval.fileList.head = yyval.fileList.last = yystack.l_mark[0].file; }
+#line 2183 "parser.c"
+break;
+case 10:
+#line 283 "parser.y"
+	{
+                            yyval.file = XkbFileCreate(yystack.l_mark[-5].file_type, yystack.l_mark[-4].str, yystack.l_mark[-2].anyList.head, yystack.l_mark[-6].mapFlags);
+                        }
+#line 2190 "parser.c"
+break;
+case 11:
+#line 288 "parser.y"
+	{ yyval.file_type = FILE_TYPE_KEYCODES; }
+#line 2195 "parser.c"
+break;
+case 12:
+#line 289 "parser.y"
+	{ yyval.file_type = FILE_TYPE_TYPES; }
+#line 2200 "parser.c"
+break;
+case 13:
+#line 290 "parser.y"
+	{ yyval.file_type = FILE_TYPE_COMPAT; }
+#line 2205 "parser.c"
+break;
+case 14:
+#line 291 "parser.y"
+	{ yyval.file_type = FILE_TYPE_SYMBOLS; }
+#line 2210 "parser.c"
+break;
+case 15:
+#line 292 "parser.y"
+	{ yyval.file_type = FILE_TYPE_GEOMETRY; }
+#line 2215 "parser.c"
+break;
+case 16:
+#line 295 "parser.y"
+	{ yyval.mapFlags = yystack.l_mark[0].mapFlags; }
+#line 2220 "parser.c"
+break;
+case 17:
+#line 296 "parser.y"
+	{ yyval.mapFlags = 0; }
+#line 2225 "parser.c"
+break;
+case 18:
+#line 299 "parser.y"
+	{ yyval.mapFlags = (yystack.l_mark[-1].mapFlags | yystack.l_mark[0].mapFlags); }
+#line 2230 "parser.c"
+break;
+case 19:
+#line 300 "parser.y"
+	{ yyval.mapFlags = yystack.l_mark[0].mapFlags; }
+#line 2235 "parser.c"
+break;
+case 20:
+#line 303 "parser.y"
+	{ yyval.mapFlags = MAP_IS_PARTIAL; }
+#line 2240 "parser.c"
+break;
+case 21:
+#line 304 "parser.y"
+	{ yyval.mapFlags = MAP_IS_DEFAULT; }
+#line 2245 "parser.c"
+break;
+case 22:
+#line 305 "parser.y"
+	{ yyval.mapFlags = MAP_IS_HIDDEN; }
+#line 2250 "parser.c"
+break;
+case 23:
+#line 306 "parser.y"
+	{ yyval.mapFlags = MAP_HAS_ALPHANUMERIC; }
+#line 2255 "parser.c"
+break;
+case 24:
+#line 307 "parser.y"
+	{ yyval.mapFlags = MAP_HAS_MODIFIER; }
+#line 2260 "parser.c"
+break;
+case 25:
+#line 308 "parser.y"
+	{ yyval.mapFlags = MAP_HAS_KEYPAD; }
+#line 2265 "parser.c"
+break;
+case 26:
+#line 309 "parser.y"
+	{ yyval.mapFlags = MAP_HAS_FN; }
+#line 2270 "parser.c"
+break;
+case 27:
+#line 310 "parser.y"
+	{ yyval.mapFlags = MAP_IS_ALTGR; }
+#line 2275 "parser.c"
+break;
+case 28:
+#line 314 "parser.y"
+	{
+                            if (yystack.l_mark[0].any) {
+                                if (yystack.l_mark[-1].anyList.head) {
+                                    yyval.anyList.head = yystack.l_mark[-1].anyList.head; yystack.l_mark[-1].anyList.last->next = yystack.l_mark[0].any; yyval.anyList.last = yystack.l_mark[0].any;
+                                } else {
+                                    yyval.anyList.head = yyval.anyList.last = yystack.l_mark[0].any;
+                                }
+                            }
+                        }
+#line 2288 "parser.c"
+break;
+case 29:
+#line 329 "parser.y"
+	{
+                            for (VModDef *vmod = yystack.l_mark[0].vmodList.head; vmod; vmod = (VModDef *) vmod->common.next)
+                                vmod->merge = yystack.l_mark[-1].merge;
+                            if (yystack.l_mark[-2].anyList.head) {
+                                yyval.anyList.head = yystack.l_mark[-2].anyList.head; yystack.l_mark[-2].anyList.last->next = &yystack.l_mark[0].vmodList.head->common; yyval.anyList.last = &yystack.l_mark[0].vmodList.last->common;
+                            } else {
+                                yyval.anyList.head = &yystack.l_mark[0].vmodList.head->common; yyval.anyList.last = &yystack.l_mark[0].vmodList.last->common;
+                            }
+                        }
+#line 2301 "parser.c"
+break;
+case 30:
+#line 338 "parser.y"
+	{ yyval.anyList.head = yyval.anyList.last = NULL; }
+#line 2306 "parser.c"
+break;
+case 31:
+#line 342 "parser.y"
+	{
+                            yystack.l_mark[0].var->merge = yystack.l_mark[-1].merge;
+                            yyval.any = (ParseCommon *) yystack.l_mark[0].var;
+                        }
+#line 2314 "parser.c"
+break;
+case 32:
+#line 348 "parser.y"
+	{
+                            yystack.l_mark[0].interp->merge = yystack.l_mark[-1].merge;
+                            yyval.any = (ParseCommon *) yystack.l_mark[0].interp;
+                        }
+#line 2322 "parser.c"
+break;
+case 33:
+#line 353 "parser.y"
+	{
+                            yystack.l_mark[0].keyCode->merge = yystack.l_mark[-1].merge;
+                            yyval.any = (ParseCommon *) yystack.l_mark[0].keyCode;
+                        }
+#line 2330 "parser.c"
+break;
+case 34:
+#line 358 "parser.y"
+	{
+                            yystack.l_mark[0].keyAlias->merge = yystack.l_mark[-1].merge;
+                            yyval.any = (ParseCommon *) yystack.l_mark[0].keyAlias;
+                        }
+#line 2338 "parser.c"
+break;
+case 35:
+#line 363 "parser.y"
+	{
+                            yystack.l_mark[0].keyType->merge = yystack.l_mark[-1].merge;
+                            yyval.any = (ParseCommon *) yystack.l_mark[0].keyType;
+                        }
+#line 2346 "parser.c"
+break;
+case 36:
+#line 368 "parser.y"
+	{
+                            yystack.l_mark[0].syms->merge = yystack.l_mark[-1].merge;
+                            yyval.any = (ParseCommon *) yystack.l_mark[0].syms;
+                        }
+#line 2354 "parser.c"
+break;
+case 37:
+#line 373 "parser.y"
+	{
+                            yystack.l_mark[0].modMask->merge = yystack.l_mark[-1].merge;
+                            yyval.any = (ParseCommon *) yystack.l_mark[0].modMask;
+                        }
+#line 2362 "parser.c"
+break;
+case 38:
+#line 378 "parser.y"
+	{
+                            yystack.l_mark[0].groupCompat->merge = yystack.l_mark[-1].merge;
+                            yyval.any = (ParseCommon *) yystack.l_mark[0].groupCompat;
+                        }
+#line 2370 "parser.c"
+break;
+case 39:
+#line 383 "parser.y"
+	{
+                            yystack.l_mark[0].ledMap->merge = yystack.l_mark[-1].merge;
+                            yyval.any = (ParseCommon *) yystack.l_mark[0].ledMap;
+                        }
+#line 2378 "parser.c"
+break;
+case 40:
+#line 388 "parser.y"
+	{
+                            yystack.l_mark[0].ledName->merge = yystack.l_mark[-1].merge;
+                            yyval.any = (ParseCommon *) yystack.l_mark[0].ledName;
+                        }
+#line 2386 "parser.c"
+break;
+case 41:
+#line 392 "parser.y"
+	{ yyval.any = NULL; }
+#line 2391 "parser.c"
+break;
+case 42:
+#line 393 "parser.y"
+	{ yyval.any = NULL; }
+#line 2396 "parser.c"
+break;
+case 43:
+#line 394 "parser.y"
+	{ yyval.any = NULL; }
+#line 2401 "parser.c"
+break;
+case 44:
+#line 396 "parser.y"
+	{
+                            yyval.any = (ParseCommon *) IncludeCreate(param->ctx, yystack.l_mark[0].str, yystack.l_mark[-1].merge);
+                            free(yystack.l_mark[0].str);
+                        }
+#line 2409 "parser.c"
+break;
+case 45:
+#line 403 "parser.y"
+	{ yyval.var = VarCreate(yystack.l_mark[-3].expr, yystack.l_mark[-1].expr); }
+#line 2414 "parser.c"
+break;
+case 46:
+#line 405 "parser.y"
+	{ yyval.var = BoolVarCreate(yystack.l_mark[-1].atom, true); }
+#line 2419 "parser.c"
+break;
+case 47:
+#line 407 "parser.y"
+	{ yyval.var = BoolVarCreate(yystack.l_mark[-1].atom, false); }
+#line 2424 "parser.c"
+break;
+case 48:
+#line 411 "parser.y"
+	{ yyval.keyCode = KeycodeCreate(yystack.l_mark[-3].atom, yystack.l_mark[-1].num); }
+#line 2429 "parser.c"
+break;
+case 49:
+#line 415 "parser.y"
+	{ yyval.keyAlias = KeyAliasCreate(yystack.l_mark[-3].atom, yystack.l_mark[-1].atom); }
+#line 2434 "parser.c"
+break;
+case 50:
+#line 419 "parser.y"
+	{ yyval.vmodList = yystack.l_mark[-1].vmodList; }
+#line 2439 "parser.c"
+break;
+case 51:
+#line 423 "parser.y"
+	{ yyval.vmodList.head = yystack.l_mark[-2].vmodList.head; yyval.vmodList.last->common.next = &yystack.l_mark[0].vmod->common; yyval.vmodList.last = yystack.l_mark[0].vmod; }
+#line 2444 "parser.c"
+break;
+case 52:
+#line 425 "parser.y"
+	{ yyval.vmodList.head = yyval.vmodList.last = yystack.l_mark[0].vmod; }
+#line 2449 "parser.c"
+break;
+case 53:
+#line 429 "parser.y"
+	{ yyval.vmod = VModCreate(yystack.l_mark[0].atom, NULL); }
+#line 2454 "parser.c"
+break;
+case 54:
+#line 431 "parser.y"
+	{ yyval.vmod = VModCreate(yystack.l_mark[-2].atom, yystack.l_mark[0].expr); }
+#line 2459 "parser.c"
+break;
+case 55:
+#line 437 "parser.y"
+	{ yystack.l_mark[-4].interp->def = yystack.l_mark[-2].varList.head; yyval.interp = yystack.l_mark[-4].interp; }
+#line 2464 "parser.c"
+break;
+case 56:
+#line 441 "parser.y"
+	{ yyval.interp = InterpCreate(yystack.l_mark[-2].keysym, yystack.l_mark[0].expr); }
+#line 2469 "parser.c"
+break;
+case 57:
+#line 443 "parser.y"
+	{ yyval.interp = InterpCreate(yystack.l_mark[0].keysym, NULL); }
+#line 2474 "parser.c"
+break;
+case 58:
+#line 447 "parser.y"
+	{ yyval.varList.head = yystack.l_mark[-1].varList.head; yyval.varList.last->common.next = &yystack.l_mark[0].var->common; yyval.varList.last = yystack.l_mark[0].var; }
+#line 2479 "parser.c"
+break;
+case 59:
+#line 449 "parser.y"
+	{ yyval.varList.head = yyval.varList.last = yystack.l_mark[0].var; }
+#line 2484 "parser.c"
+break;
+case 60:
+#line 455 "parser.y"
+	{ yyval.keyType = KeyTypeCreate(yystack.l_mark[-4].atom, yystack.l_mark[-2].varList.head); }
+#line 2489 "parser.c"
+break;
+case 61:
+#line 461 "parser.y"
+	{ yyval.syms = SymbolsCreate(yystack.l_mark[-4].atom, yystack.l_mark[-2].varList.head); }
+#line 2494 "parser.c"
+break;
+case 62:
+#line 465 "parser.y"
+	{ yyval.varList.head = yystack.l_mark[-2].varList.head; yyval.varList.last->common.next = &yystack.l_mark[0].var->common; yyval.varList.last = yystack.l_mark[0].var; }
+#line 2499 "parser.c"
+break;
+case 63:
+#line 467 "parser.y"
+	{ yyval.varList.head = yyval.varList.last = yystack.l_mark[0].var; }
+#line 2504 "parser.c"
+break;
+case 64:
+#line 470 "parser.y"
+	{ yyval.var = VarCreate(yystack.l_mark[-2].expr, yystack.l_mark[0].expr); }
+#line 2509 "parser.c"
+break;
+case 65:
+#line 471 "parser.y"
+	{ yyval.var = VarCreate(yystack.l_mark[-2].expr, yystack.l_mark[0].expr); }
+#line 2514 "parser.c"
+break;
+case 66:
+#line 472 "parser.y"
+	{ yyval.var = BoolVarCreate(yystack.l_mark[0].atom, true); }
+#line 2519 "parser.c"
+break;
+case 67:
+#line 473 "parser.y"
+	{ yyval.var = BoolVarCreate(yystack.l_mark[0].atom, false); }
+#line 2524 "parser.c"
+break;
+case 68:
+#line 474 "parser.y"
+	{ yyval.var = VarCreate(NULL, yystack.l_mark[0].expr); }
+#line 2529 "parser.c"
+break;
+case 69:
+#line 478 "parser.y"
+	{ yyval.expr = yystack.l_mark[-1].expr; }
+#line 2534 "parser.c"
+break;
+case 70:
+#line 480 "parser.y"
+	{ yyval.expr = ExprCreateActionList(yystack.l_mark[-1].exprList.head); }
+#line 2539 "parser.c"
+break;
+case 71:
+#line 484 "parser.y"
+	{ yyval.groupCompat = GroupCompatCreate(yystack.l_mark[-3].num, yystack.l_mark[-1].expr); }
+#line 2544 "parser.c"
+break;
+case 72:
+#line 488 "parser.y"
+	{ yyval.modMask = ModMapCreate(yystack.l_mark[-4].atom, yystack.l_mark[-2].exprList.head); }
+#line 2549 "parser.c"
+break;
+case 73:
+#line 492 "parser.y"
+	{ yyval.ledMap = LedMapCreate(yystack.l_mark[-4].atom, yystack.l_mark[-2].varList.head); }
+#line 2554 "parser.c"
+break;
+case 74:
+#line 496 "parser.y"
+	{ yyval.ledName = LedNameCreate(yystack.l_mark[-3].num, yystack.l_mark[-1].expr, false); }
+#line 2559 "parser.c"
+break;
+case 75:
+#line 498 "parser.y"
+	{ yyval.ledName = LedNameCreate(yystack.l_mark[-3].num, yystack.l_mark[-1].expr, true); }
+#line 2564 "parser.c"
+break;
+case 76:
+#line 502 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2569 "parser.c"
+break;
+case 77:
+#line 504 "parser.y"
+	{ (void) yystack.l_mark[-2].expr; yyval.geom = NULL; }
+#line 2574 "parser.c"
+break;
+case 78:
+#line 508 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2579 "parser.c"
+break;
+case 79:
+#line 511 "parser.y"
+	{ yyval.geom = NULL;}
+#line 2584 "parser.c"
+break;
+case 80:
+#line 512 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2589 "parser.c"
+break;
+case 81:
+#line 516 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2594 "parser.c"
+break;
+case 82:
+#line 518 "parser.y"
+	{ FreeStmt((ParseCommon *) yystack.l_mark[0].var); yyval.geom = NULL; }
+#line 2599 "parser.c"
+break;
+case 83:
+#line 520 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2604 "parser.c"
+break;
+case 84:
+#line 522 "parser.y"
+	{ FreeStmt((ParseCommon *) yystack.l_mark[0].ledMap); yyval.geom = NULL; }
+#line 2609 "parser.c"
+break;
+case 85:
+#line 524 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2614 "parser.c"
+break;
+case 86:
+#line 527 "parser.y"
+	{ yyval.geom = NULL;}
+#line 2619 "parser.c"
+break;
+case 87:
+#line 528 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2624 "parser.c"
+break;
+case 88:
+#line 531 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2629 "parser.c"
+break;
+case 89:
+#line 533 "parser.y"
+	{ FreeStmt((ParseCommon *) yystack.l_mark[0].var); yyval.geom = NULL; }
+#line 2634 "parser.c"
+break;
+case 90:
+#line 536 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2639 "parser.c"
+break;
+case 91:
+#line 537 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2644 "parser.c"
+break;
+case 92:
+#line 541 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2649 "parser.c"
+break;
+case 93:
+#line 543 "parser.y"
+	{ FreeStmt((ParseCommon *) yystack.l_mark[-1].exprList.head); yyval.geom = NULL; }
+#line 2654 "parser.c"
+break;
+case 94:
+#line 547 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2659 "parser.c"
+break;
+case 95:
+#line 550 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2664 "parser.c"
+break;
+case 96:
+#line 551 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2669 "parser.c"
+break;
+case 97:
+#line 554 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2674 "parser.c"
+break;
+case 98:
+#line 558 "parser.y"
+	{ yyval.geom = NULL;}
+#line 2679 "parser.c"
+break;
+case 99:
+#line 560 "parser.y"
+	{ yyval.geom = NULL; }
+#line 2684 "parser.c"
+break;
+case 100:
+#line 564 "parser.y"
+	{ (void) yystack.l_mark[-1].expr; yyval.geom = NULL; }
+#line 2689 "parser.c"
+break;
+case 101:
+#line 566 "parser.y"
+	{ (void) yystack.l_mark[-1].expr; yyval.geom = NULL; }
+#line 2694 "parser.c"
+break;
+case 102:
+#line 568 "parser.y"
+	{ FreeStmt((ParseCommon *) yystack.l_mark[0].expr); yyval.geom = NULL; }
+#line 2699 "parser.c"
+break;
+case 103:
+#line 572 "parser.y"
+	{ (void) yystack.l_mark[-2].expr; (void) yystack.l_mark[0].expr; yyval.expr = NULL; }
+#line 2704 "parser.c"
+break;
+case 104:
+#line 574 "parser.y"
+	{ (void) yystack.l_mark[0].expr; yyval.expr = NULL; }
+#line 2709 "parser.c"
+break;
+case 105:
+#line 578 "parser.y"
+	{ yyval.expr = NULL; }
+#line 2714 "parser.c"
+break;
+case 106:
+#line 582 "parser.y"
+	{ FreeStmt((ParseCommon *) yystack.l_mark[-2].varList.head); yyval.geom = NULL; }
+#line 2719 "parser.c"
+break;
+case 107:
+#line 585 "parser.y"
+	{ yyval.num = 0; }
+#line 2724 "parser.c"
+break;
+case 108:
+#line 586 "parser.y"
+	{ yyval.num = 0; }
+#line 2729 "parser.c"
+break;
+case 109:
+#line 587 "parser.y"
+	{ yyval.num = 0; }
+#line 2734 "parser.c"
+break;
+case 110:
+#line 588 "parser.y"
+	{ yyval.num = 0; }
+#line 2739 "parser.c"
+break;
+case 111:
+#line 591 "parser.y"
+	{ yyval.atom = yystack.l_mark[0].atom; }
+#line 2744 "parser.c"
+break;
+case 112:
+#line 592 "parser.y"
+	{ yyval.atom = yystack.l_mark[0].atom; }
+#line 2749 "parser.c"
+break;
+case 113:
+#line 596 "parser.y"
+	{ yyval.atom = xkb_atom_intern_literal(param->ctx, "action"); }
+#line 2754 "parser.c"
+break;
+case 114:
+#line 598 "parser.y"
+	{ yyval.atom = xkb_atom_intern_literal(param->ctx, "interpret"); }
+#line 2759 "parser.c"
+break;
+case 115:
+#line 600 "parser.y"
+	{ yyval.atom = xkb_atom_intern_literal(param->ctx, "type"); }
+#line 2764 "parser.c"
+break;
+case 116:
+#line 602 "parser.y"
+	{ yyval.atom = xkb_atom_intern_literal(param->ctx, "key"); }
+#line 2769 "parser.c"
+break;
+case 117:
+#line 604 "parser.y"
+	{ yyval.atom = xkb_atom_intern_literal(param->ctx, "group"); }
+#line 2774 "parser.c"
+break;
+case 118:
+#line 606 "parser.y"
+	{yyval.atom = xkb_atom_intern_literal(param->ctx, "modifier_map");}
+#line 2779 "parser.c"
+break;
+case 119:
+#line 608 "parser.y"
+	{ yyval.atom = xkb_atom_intern_literal(param->ctx, "indicator"); }
+#line 2784 "parser.c"
+break;
+case 120:
+#line 610 "parser.y"
+	{ yyval.atom = xkb_atom_intern_literal(param->ctx, "shape"); }
+#line 2789 "parser.c"
+break;
+case 121:
+#line 612 "parser.y"
+	{ yyval.atom = xkb_atom_intern_literal(param->ctx, "row"); }
+#line 2794 "parser.c"
+break;
+case 122:
+#line 614 "parser.y"
+	{ yyval.atom = xkb_atom_intern_literal(param->ctx, "section"); }
+#line 2799 "parser.c"
+break;
+case 123:
+#line 616 "parser.y"
+	{ yyval.atom = xkb_atom_intern_literal(param->ctx, "text"); }
+#line 2804 "parser.c"
+break;
+case 124:
+#line 619 "parser.y"
+	{ yyval.merge = yystack.l_mark[0].merge; }
+#line 2809 "parser.c"
+break;
+case 125:
+#line 620 "parser.y"
+	{ yyval.merge = MERGE_DEFAULT; }
+#line 2814 "parser.c"
+break;
+case 126:
+#line 623 "parser.y"
+	{ yyval.merge = MERGE_DEFAULT; }
+#line 2819 "parser.c"
+break;
+case 127:
+#line 624 "parser.y"
+	{ yyval.merge = MERGE_AUGMENT; }
+#line 2824 "parser.c"
+break;
+case 128:
+#line 625 "parser.y"
+	{ yyval.merge = MERGE_OVERRIDE; }
+#line 2829 "parser.c"
+break;
+case 129:
+#line 626 "parser.y"
+	{ yyval.merge = MERGE_REPLACE; }
+#line 2834 "parser.c"
+break;
+case 130:
+#line 628 "parser.y"
+	{
+                    /*
+                     * This used to be MERGE_ALT_FORM. This functionality was
+                     * unused and has been removed.
+                     */
+                    yyval.merge = MERGE_DEFAULT;
+                }
+#line 2845 "parser.c"
+break;
+case 131:
+#line 637 "parser.y"
+	{ yyval.exprList = yystack.l_mark[0].exprList; }
+#line 2850 "parser.c"
+break;
+case 132:
+#line 638 "parser.y"
+	{ yyval.exprList.head = yyval.exprList.last = NULL; }
+#line 2855 "parser.c"
+break;
+case 133:
+#line 642 "parser.y"
+	{ yyval.exprList.head = yystack.l_mark[-2].exprList.head; yyval.exprList.last->common.next = &yystack.l_mark[0].expr->common; yyval.exprList.last = yystack.l_mark[0].expr; }
+#line 2860 "parser.c"
+break;
+case 134:
+#line 644 "parser.y"
+	{ yyval.exprList.head = yyval.exprList.last = yystack.l_mark[0].expr; }
+#line 2865 "parser.c"
+break;
+case 135:
+#line 648 "parser.y"
+	{ yyval.expr = ExprCreateBinary(EXPR_DIVIDE, yystack.l_mark[-2].expr, yystack.l_mark[0].expr); }
+#line 2870 "parser.c"
+break;
+case 136:
+#line 650 "parser.y"
+	{ yyval.expr = ExprCreateBinary(EXPR_ADD, yystack.l_mark[-2].expr, yystack.l_mark[0].expr); }
+#line 2875 "parser.c"
+break;
+case 137:
+#line 652 "parser.y"
+	{ yyval.expr = ExprCreateBinary(EXPR_SUBTRACT, yystack.l_mark[-2].expr, yystack.l_mark[0].expr); }
+#line 2880 "parser.c"
+break;
+case 138:
+#line 654 "parser.y"
+	{ yyval.expr = ExprCreateBinary(EXPR_MULTIPLY, yystack.l_mark[-2].expr, yystack.l_mark[0].expr); }
+#line 2885 "parser.c"
+break;
+case 139:
+#line 656 "parser.y"
+	{ yyval.expr = ExprCreateBinary(EXPR_ASSIGN, yystack.l_mark[-2].expr, yystack.l_mark[0].expr); }
+#line 2890 "parser.c"
+break;
+case 140:
+#line 658 "parser.y"
+	{ yyval.expr = yystack.l_mark[0].expr; }
+#line 2895 "parser.c"
+break;
+case 141:
+#line 662 "parser.y"
+	{ yyval.expr = ExprCreateUnary(EXPR_NEGATE, yystack.l_mark[0].expr->expr.value_type, yystack.l_mark[0].expr); }
+#line 2900 "parser.c"
+break;
+case 142:
+#line 664 "parser.y"
+	{ yyval.expr = ExprCreateUnary(EXPR_UNARY_PLUS, yystack.l_mark[0].expr->expr.value_type, yystack.l_mark[0].expr); }
+#line 2905 "parser.c"
+break;
+case 143:
+#line 666 "parser.y"
+	{ yyval.expr = ExprCreateUnary(EXPR_NOT, EXPR_TYPE_BOOLEAN, yystack.l_mark[0].expr); }
+#line 2910 "parser.c"
+break;
+case 144:
+#line 668 "parser.y"
+	{ yyval.expr = ExprCreateUnary(EXPR_INVERT, yystack.l_mark[0].expr->expr.value_type, yystack.l_mark[0].expr); }
+#line 2915 "parser.c"
+break;
+case 145:
+#line 670 "parser.y"
+	{ yyval.expr = yystack.l_mark[0].expr;  }
+#line 2920 "parser.c"
+break;
+case 146:
+#line 672 "parser.y"
+	{ yyval.expr = ExprCreateAction(yystack.l_mark[-3].atom, yystack.l_mark[-1].exprList.head); }
+#line 2925 "parser.c"
+break;
+case 147:
+#line 674 "parser.y"
+	{ yyval.expr = yystack.l_mark[0].expr;  }
+#line 2930 "parser.c"
+break;
+case 148:
+#line 676 "parser.y"
+	{ yyval.expr = yystack.l_mark[-1].expr;  }
+#line 2935 "parser.c"
+break;
+case 149:
+#line 680 "parser.y"
+	{ yyval.exprList.head = yystack.l_mark[-2].exprList.head; yyval.exprList.last->common.next = &yystack.l_mark[0].expr->common; yyval.exprList.last = yystack.l_mark[0].expr; }
+#line 2940 "parser.c"
+break;
+case 150:
+#line 682 "parser.y"
+	{ yyval.exprList.head = yyval.exprList.last = yystack.l_mark[0].expr; }
+#line 2945 "parser.c"
+break;
+case 151:
+#line 686 "parser.y"
+	{ yyval.expr = ExprCreateAction(yystack.l_mark[-3].atom, yystack.l_mark[-1].exprList.head); }
+#line 2950 "parser.c"
+break;
+case 152:
+#line 690 "parser.y"
+	{ yyval.expr = ExprCreateIdent(yystack.l_mark[0].atom); }
+#line 2955 "parser.c"
+break;
+case 153:
+#line 692 "parser.y"
+	{ yyval.expr = ExprCreateFieldRef(yystack.l_mark[-2].atom, yystack.l_mark[0].atom); }
+#line 2960 "parser.c"
+break;
+case 154:
+#line 694 "parser.y"
+	{ yyval.expr = ExprCreateArrayRef(XKB_ATOM_NONE, yystack.l_mark[-3].atom, yystack.l_mark[-1].expr); }
+#line 2965 "parser.c"
+break;
+case 155:
+#line 696 "parser.y"
+	{ yyval.expr = ExprCreateArrayRef(yystack.l_mark[-5].atom, yystack.l_mark[-3].atom, yystack.l_mark[-1].expr); }
+#line 2970 "parser.c"
+break;
+case 156:
+#line 700 "parser.y"
+	{ yyval.expr = ExprCreateString(yystack.l_mark[0].atom); }
+#line 2975 "parser.c"
+break;
+case 157:
+#line 702 "parser.y"
+	{ yyval.expr = ExprCreateInteger(yystack.l_mark[0].num); }
+#line 2980 "parser.c"
+break;
+case 158:
+#line 704 "parser.y"
+	{ yyval.expr = ExprCreateFloat(/* Discard $1 */); }
+#line 2985 "parser.c"
+break;
+case 159:
+#line 706 "parser.y"
+	{ yyval.expr = ExprCreateKeyName(yystack.l_mark[0].atom); }
+#line 2990 "parser.c"
+break;
+case 160:
+#line 709 "parser.y"
+	{ yyval.expr = yystack.l_mark[0].expr; }
+#line 2995 "parser.c"
+break;
+case 161:
+#line 710 "parser.y"
+	{ yyval.expr = NULL; }
+#line 3000 "parser.c"
+break;
+case 162:
+#line 714 "parser.y"
+	{ yyval.expr = ExprAppendKeysymList(yystack.l_mark[-2].expr, yystack.l_mark[0].keysym); }
+#line 3005 "parser.c"
+break;
+case 163:
+#line 716 "parser.y"
+	{ yyval.expr = ExprAppendMultiKeysymList(yystack.l_mark[-2].expr, yystack.l_mark[0].expr); }
+#line 3010 "parser.c"
+break;
+case 164:
+#line 718 "parser.y"
+	{ yyval.expr = ExprCreateKeysymList(yystack.l_mark[0].keysym); }
+#line 3015 "parser.c"
+break;
+case 165:
+#line 720 "parser.y"
+	{ yyval.expr = ExprCreateMultiKeysymList(yystack.l_mark[0].expr); }
+#line 3020 "parser.c"
+break;
+case 166:
+#line 724 "parser.y"
+	{ yyval.expr = yystack.l_mark[-1].expr; }
+#line 3025 "parser.c"
+break;
+case 167:
+#line 728 "parser.y"
+	{
+                            if (!resolve_keysym(yystack.l_mark[0].str, &yyval.keysym)) {
+                                parser_warn(
+                                    param,
+                                    XKB_WARNING_UNRECOGNIZED_KEYSYM,
+                                    "unrecognized keysym \"%s\"",
+                                    yystack.l_mark[0].str
+                                );
+                                yyval.keysym = XKB_KEY_NoSymbol;
+                            }
+                            free(yystack.l_mark[0].str);
+                        }
+#line 3041 "parser.c"
+break;
+case 168:
+#line 740 "parser.y"
+	{ yyval.keysym = XKB_KEY_section; }
+#line 3046 "parser.c"
+break;
+case 169:
+#line 742 "parser.y"
+	{
+                            if (yystack.l_mark[0].num < XKB_KEYSYM_MIN) {
+                                parser_warn(
+                                    param,
+                                    XKB_WARNING_UNRECOGNIZED_KEYSYM,
+                                    "unrecognized keysym \"%"PRId64"\"",
+                                    yystack.l_mark[0].num
+                                );
+                                yyval.keysym = XKB_KEY_NoSymbol;
+                            }
+                            /* Special case for digits 0..9 */
+                            else if (yystack.l_mark[0].num < 10) {      /* XKB_KEY_0 .. XKB_KEY_9 */
+                                yyval.keysym = XKB_KEY_0 + (xkb_keysym_t) yystack.l_mark[0].num;
+                            }
+                            else {
+                                if (yystack.l_mark[0].num <= XKB_KEYSYM_MAX) {
+                                    yyval.keysym = (xkb_keysym_t) yystack.l_mark[0].num;
+                                } else {
+                                    parser_warn(
+                                        param, XKB_WARNING_UNRECOGNIZED_KEYSYM,
+                                        "unrecognized keysym \"0x%"PRIx64"\" "
+                                        "(%"PRId64")", yystack.l_mark[0].num, yystack.l_mark[0].num
+                                    );
+                                    yyval.keysym = XKB_KEY_NoSymbol;
+                                }
+                                parser_warn(
+                                    param, XKB_WARNING_NUMERIC_KEYSYM,
+                                    "numeric keysym \"0x%"PRIx64"\" (%"PRId64")",
+                                    yystack.l_mark[0].num, yystack.l_mark[0].num
+                                );
+                            }
+                        }
+#line 3082 "parser.c"
+break;
+case 170:
+#line 776 "parser.y"
+	{ yyval.num = -yystack.l_mark[0].num; }
+#line 3087 "parser.c"
+break;
+case 171:
+#line 777 "parser.y"
+	{ yyval.num = yystack.l_mark[0].num; }
+#line 3092 "parser.c"
+break;
+case 172:
+#line 780 "parser.y"
+	{ yyval.num = yystack.l_mark[0].num; }
+#line 3097 "parser.c"
+break;
+case 173:
+#line 781 "parser.y"
+	{ yyval.num = yystack.l_mark[0].num; }
+#line 3102 "parser.c"
+break;
+case 174:
+#line 784 "parser.y"
+	{ yyval.num = 0; }
+#line 3107 "parser.c"
+break;
+case 175:
+#line 787 "parser.y"
+	{ yyval.num = yystack.l_mark[0].num; }
+#line 3112 "parser.c"
+break;
+case 176:
+#line 790 "parser.y"
+	{ yyval.num = yystack.l_mark[0].num; }
+#line 3117 "parser.c"
+break;
+case 177:
+#line 793 "parser.y"
+	{ yyval.atom = xkb_atom_intern(param->ctx, yystack.l_mark[0].str, strlen(yystack.l_mark[0].str)); free(yystack.l_mark[0].str); }
+#line 3122 "parser.c"
+break;
+case 178:
+#line 794 "parser.y"
+	{ yyval.atom = xkb_atom_intern_literal(param->ctx, "default"); }
+#line 3127 "parser.c"
+break;
+case 179:
+#line 797 "parser.y"
+	{ yyval.atom = xkb_atom_intern(param->ctx, yystack.l_mark[0].str, strlen(yystack.l_mark[0].str)); free(yystack.l_mark[0].str); }
+#line 3132 "parser.c"
+break;
+case 180:
+#line 800 "parser.y"
+	{ yyval.str = yystack.l_mark[0].str; }
+#line 3137 "parser.c"
+break;
+case 181:
+#line 801 "parser.y"
+	{ yyval.str = NULL; }
+#line 3142 "parser.c"
+break;
+case 182:
+#line 804 "parser.y"
+	{ yyval.str = yystack.l_mark[0].str; }
+#line 3147 "parser.c"
+break;
+#line 3149 "parser.c"
+    default:
+        break;
+    }
+    yystack.s_mark -= yym;
+    yystate = *yystack.s_mark;
+    yystack.l_mark -= yym;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    yystack.p_mark -= yym;
+#endif
+    yym = yylhs[yyn];
+    if (yystate == 0 && yym == 0)
+    {
+#if YYDEBUG
+        if (yydebug)
+        {
+            fprintf(stderr, "%s[%d]: after reduction, ", YYDEBUGSTR, yydepth);
+#ifdef YYSTYPE_TOSTRING
+#if YYBTYACC
+            if (!yytrial)
+#endif /* YYBTYACC */
+                fprintf(stderr, "result is <%s>, ", YYSTYPE_TOSTRING(yystos[YYFINAL], yyval));
+#endif
+            fprintf(stderr, "shifting from state 0 to final state %d\n", YYFINAL);
+        }
+#endif
+        yystate = YYFINAL;
+        *++yystack.s_mark = YYFINAL;
+        *++yystack.l_mark = yyval;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+        *++yystack.p_mark = yyloc;
+#endif
+        if (yychar < 0)
+        {
+#if YYBTYACC
+            do {
+            if (yylvp < yylve)
+            {
+                /* we're currently re-reading tokens */
+                yylval = *yylvp++;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                yylloc = *yylpp++;
+#endif
+                yychar = *yylexp++;
+                break;
+            }
+            if (yyps->save)
+            {
+                /* in trial mode; save scanner results for future parse attempts */
+                if (yylvp == yylvlim)
+                {   /* Enlarge lexical value queue */
+                    size_t p = (size_t) (yylvp - yylvals);
+                    size_t s = (size_t) (yylvlim - yylvals);
+
+                    s += YYLVQUEUEGROWTH;
+                    if ((yylexemes = (YYINT *)realloc(yylexemes, s * sizeof(YYINT))) == NULL)
+                        goto yyenomem;
+                    if ((yylvals   = (YYSTYPE *)realloc(yylvals, s * sizeof(YYSTYPE))) == NULL)
+                        goto yyenomem;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                    if ((yylpsns   = (YYLTYPE *)realloc(yylpsns, s * sizeof(YYLTYPE))) == NULL)
+                        goto yyenomem;
+#endif
+                    yylvp   = yylve = yylvals + p;
+                    yylvlim = yylvals + s;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                    yylpp   = yylpe = yylpsns + p;
+                    yylplim = yylpsns + s;
+#endif
+                    yylexp  = yylexemes + p;
+                }
+                *yylexp = (YYINT) YYLEX;
+                *yylvp++ = yylval;
+                yylve++;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+                *yylpp++ = yylloc;
+                yylpe++;
+#endif
+                yychar = *yylexp++;
+                break;
+            }
+            /* normal operation, no conflict encountered */
+#endif /* YYBTYACC */
+            yychar = YYLEX;
+#if YYBTYACC
+            } while (0);
+#endif /* YYBTYACC */
+            if (yychar < 0) yychar = YYEOF;
+#if YYDEBUG
+            if (yydebug)
+            {
+                if ((yys = yyname[YYTRANSLATE(yychar)]) == NULL) yys = yyname[YYUNDFTOKEN];
+                fprintf(stderr, "%s[%d]: state %d, reading token %d (%s)\n",
+                                YYDEBUGSTR, yydepth, YYFINAL, yychar, yys);
+            }
+#endif
+        }
+        if (yychar == YYEOF) goto yyaccept;
+        goto yyloop;
+    }
+    if (((yyn = yygindex[yym]) != 0) && (yyn += yystate) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == (YYINT) yystate)
+        yystate = yytable[yyn];
+    else
+        yystate = yydgoto[yym];
+#if YYDEBUG
+    if (yydebug)
+    {
+        fprintf(stderr, "%s[%d]: after reduction, ", YYDEBUGSTR, yydepth);
+#ifdef YYSTYPE_TOSTRING
+#if YYBTYACC
+        if (!yytrial)
+#endif /* YYBTYACC */
+            fprintf(stderr, "result is <%s>, ", YYSTYPE_TOSTRING(yystos[yystate], yyval));
+#endif
+        fprintf(stderr, "shifting from state %d to state %d\n", *yystack.s_mark, yystate);
+    }
+#endif
+    if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
+    *++yystack.s_mark = (YYINT) yystate;
+    *++yystack.l_mark = yyval;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    *++yystack.p_mark = yyloc;
+#endif
+    goto yyloop;
+#if YYBTYACC
+
+    /* Reduction declares that this path is valid. Set yypath and do a full parse */
+yyvalid:
+    if (yypath) YYABORT;
+    while (yyps->save)
+    {
+        YYParseState *save = yyps->save;
+        yyps->save = save->save;
+        save->save = yypath;
+        yypath = save;
+    }
+#if YYDEBUG
+    if (yydebug)
+        fprintf(stderr, "%s[%d]: state %d, CONFLICT trial successful, backtracking to state %d, %d tokens\n",
+                        YYDEBUGSTR, yydepth, yystate, yypath->state, (int)(yylvp - yylvals - yypath->lexeme));
+#endif
+    if (yyerrctx)
+    {
+        yyFreeState(yyerrctx);
+        yyerrctx = NULL;
+    }
+    yylvp          = yylvals + yypath->lexeme;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    yylpp          = yylpsns + yypath->lexeme;
+#endif
+    yylexp         = yylexemes + yypath->lexeme;
+    yychar         = YYEMPTY;
+    yystack.s_mark = yystack.s_base + (yypath->yystack.s_mark - yypath->yystack.s_base);
+    memcpy (yystack.s_base, yypath->yystack.s_base, (size_t) (yystack.s_mark - yystack.s_base + 1) * sizeof(YYINT));
+    yystack.l_mark = yystack.l_base + (yypath->yystack.l_mark - yypath->yystack.l_base);
+    memcpy (yystack.l_base, yypath->yystack.l_base, (size_t) (yystack.l_mark - yystack.l_base + 1) * sizeof(YYSTYPE));
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+    yystack.p_mark = yystack.p_base + (yypath->yystack.p_mark - yypath->yystack.p_base);
+    memcpy (yystack.p_base, yypath->yystack.p_base, (size_t) (yystack.p_mark - yystack.p_base + 1) * sizeof(YYLTYPE));
+#endif
+    yystate        = yypath->state;
+    goto yyloop;
+#endif /* YYBTYACC */
+
+yyoverflow:
+    YYERROR_CALL("yacc stack overflow");
+#if YYBTYACC
+    goto yyabort_nomem;
+yyenomem:
+    YYERROR_CALL("memory exhausted");
+yyabort_nomem:
+#endif /* YYBTYACC */
+    yyresult = 2;
+    goto yyreturn;
+
+yyabort:
+    yyresult = 1;
+    goto yyreturn;
+
+yyaccept:
+#if YYBTYACC
+    if (yyps->save) goto yyvalid;
+#endif /* YYBTYACC */
+    yyresult = 0;
+
+yyreturn:
+#if defined(YYDESTRUCT_CALL)
+    if (yychar != YYEOF && yychar != YYEMPTY)
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+        YYDESTRUCT_CALL("cleanup: discarding token", yychar, &yylval, &yylloc);
+#else
+        YYDESTRUCT_CALL("cleanup: discarding token", yychar, &yylval);
+#endif /* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
+
+    {
+        YYSTYPE *pv;
+#if defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED)
+        YYLTYPE *pp;
+
+        for (pv = yystack.l_base, pp = yystack.p_base; pv <= yystack.l_mark; ++pv, ++pp)
+             YYDESTRUCT_CALL("cleanup: discarding state",
+                             yystos[*(yystack.s_base + (pv - yystack.l_base))], pv, pp);
+#else
+        for (pv = yystack.l_base; pv <= yystack.l_mark; ++pv)
+             YYDESTRUCT_CALL("cleanup: discarding state",
+                             yystos[*(yystack.s_base + (pv - yystack.l_base))], pv);
+#endif /* defined(YYLTYPE) || defined(YYLTYPE_IS_DECLARED) */
+    }
+#endif /* defined(YYDESTRUCT_CALL) */
+
+#if YYBTYACC
+    if (yyerrctx)
+    {
+        yyFreeState(yyerrctx);
+        yyerrctx = NULL;
+    }
+    while (yyps)
+    {
+        YYParseState *save = yyps;
+        yyps = save->save;
+        save->save = NULL;
+        yyFreeState(save);
+    }
+    while (yypath)
+    {
+        YYParseState *save = yypath;
+        yypath = save->save;
+        save->save = NULL;
+        yyFreeState(save);
+    }
+#endif /* YYBTYACC */
+    yyfreestack(&yystack);
+    return (yyresult);
+}
diff --git a/src/xkbcomp/parser.h b/src/xkbcomp/parser.h
new file mode 100644
index 0000000..86f7a92
--- /dev/null
+++ b/src/xkbcomp/parser.h
@@ -0,0 +1,104 @@
+#ifndef __xkbcommon__defines_h_
+#define __xkbcommon__defines_h_
+
+#define END_OF_FILE 0
+#define ERROR_TOK 255
+#define XKB_KEYMAP 1
+#define XKB_KEYCODES 2
+#define XKB_TYPES 3
+#define XKB_SYMBOLS 4
+#define XKB_COMPATMAP 5
+#define XKB_GEOMETRY 6
+#define XKB_SEMANTICS 7
+#define XKB_LAYOUT 8
+#define INCLUDE 10
+#define OVERRIDE 11
+#define AUGMENT 12
+#define REPLACE 13
+#define ALTERNATE 14
+#define VIRTUAL_MODS 20
+#define TYPE 21
+#define INTERPRET 22
+#define ACTION_TOK 23
+#define KEY 24
+#define ALIAS 25
+#define GROUP 26
+#define MODIFIER_MAP 27
+#define INDICATOR 28
+#define SHAPE 29
+#define KEYS 30
+#define ROW 31
+#define SECTION 32
+#define OVERLAY 33
+#define TEXT 34
+#define OUTLINE 35
+#define SOLID 36
+#define LOGO 37
+#define VIRTUAL 38
+#define EQUALS 40
+#define PLUS 41
+#define MINUS 42
+#define DIVIDE 43
+#define TIMES 44
+#define OBRACE 45
+#define CBRACE 46
+#define OPAREN 47
+#define CPAREN 48
+#define OBRACKET 49
+#define CBRACKET 50
+#define DOT 51
+#define COMMA 52
+#define SEMI 53
+#define EXCLAM 54
+#define INVERT 55
+#define STRING 60
+#define INTEGER 61
+#define FLOAT 62
+#define IDENT 63
+#define KEYNAME 64
+#define PARTIAL 70
+#define DEFAULT 71
+#define HIDDEN 72
+#define ALPHANUMERIC_KEYS 73
+#define MODIFIER_KEYS 74
+#define KEYPAD_KEYS 75
+#define FUNCTION_KEYS 76
+#define ALTERNATE_GROUP 77
+#ifdef YYSTYPE
+#undef  YYSTYPE_IS_DECLARED
+#define YYSTYPE_IS_DECLARED 1
+#endif
+#ifndef YYSTYPE_IS_DECLARED
+#define YYSTYPE_IS_DECLARED 1
+typedef union YYSTYPE  {
+        int64_t          num;
+        enum xkb_file_type file_type;
+        char            *str;
+        xkb_atom_t      atom;
+        enum merge_mode merge;
+        enum xkb_map_flags mapFlags;
+        xkb_keysym_t    keysym;
+        ParseCommon     *any;
+        struct { ParseCommon *head; ParseCommon *last; } anyList;
+        ExprDef         *expr;
+        struct { ExprDef *head; ExprDef *last; } exprList;
+        VarDef          *var;
+        struct { VarDef *head; VarDef *last; } varList;
+        VModDef         *vmod;
+        struct { VModDef *head; VModDef *last; } vmodList;
+        InterpDef       *interp;
+        KeyTypeDef      *keyType;
+        SymbolsDef      *syms;
+        ModMapDef       *modMask;
+        GroupCompatDef  *groupCompat;
+        LedMapDef       *ledMap;
+        LedNameDef      *ledName;
+        KeycodeDef      *keyCode;
+        KeyAliasDef     *keyAlias;
+        void            *geom;
+        XkbFile         *file;
+        struct { XkbFile *head; XkbFile *last; } fileList;
+} YYSTYPE;
+#endif /* !YYSTYPE_IS_DECLARED */
+
+#endif /* __xkbcommon__defines_h_ */
-- 
2.45.1

